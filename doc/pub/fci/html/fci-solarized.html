<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Full configuration interaction theory">

<title>Full configuration interaction theory</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="https://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Slater determinants as basis states, Repetition',
               2,
               None,
               '___sec0'),
              ('Slater determinants as basis states, repetition',
               2,
               None,
               '___sec1'),
              ('Slater determinants as basis states', 2, None, '___sec2'),
              ('Slater determinants as basis states', 2, None, '___sec3'),
              ('Quick repetition of the occupation representation',
               2,
               None,
               '___sec4'),
              ('Quick repetition  of the occupation representation',
               2,
               None,
               '___sec5'),
              ('Quick repetition  of the occupation representation',
               2,
               None,
               '___sec6'),
              ('Full Configuration Interaction Theory', 2, None, '___sec7'),
              ('Full Configuration Interaction Theory', 2, None, '___sec8'),
              ('Full Configuration Interaction Theory', 2, None, '___sec9'),
              ('Full Configuration Interaction Theory', 2, None, '___sec10'),
              ('Full Configuration Interaction Theory', 2, None, '___sec11'),
              ('Full Configuration Interaction Theory', 2, None, '___sec12'),
              ('Example of a Hamiltonian matrix', 2, None, '___sec13'),
              ('Example of a Hamiltonian matrix with a Hartree-Fock basis',
               2,
               None,
               '___sec14'),
              ('Shell-model jargon', 2, None, '___sec15'),
              ('FCI and the exponential growth', 2, None, '___sec16'),
              ('Exponential wall', 2, None, '___sec17'),
              ('A non-practical way of solving the eigenvalue problem',
               2,
               None,
               '___sec18'),
              ('A non-practical way of solving the eigenvalue problem',
               2,
               None,
               '___sec19'),
              ('A non-practical way of solving the eigenvalue problem',
               2,
               None,
               '___sec20'),
              ('Rewriting the FCI equation', 2, None, '___sec21'),
              ('Rewriting the FCI equation', 2, None, '___sec22'),
              ('Rewriting the FCI equation, does not stop here',
               2,
               None,
               '___sec23'),
              ('Rewriting the FCI equation, please stop here',
               2,
               None,
               '___sec24'),
              ('Rewriting the FCI equation, more to add', 2, None, '___sec25'),
              ('Rewriting the FCI equation, more to add', 2, None, '___sec26'),
              ('Summarizing FCI and bringing in approximative methods',
               2,
               None,
               '___sec27'),
              ('Definition of the correlation energy', 2, None, '___sec28'),
              ('FCI equation and the coefficients', 2, None, '___sec29'),
              ('Important ingredients to have in codes', 2, None, '___sec30'),
              ('A structured approach to solving problems',
               2,
               None,
               '___sec31'),
              ('Additional benefits', 2, None, '___sec32'),
              ('Unit Testing', 2, None, '___sec33'),
              ('Unit Testing, benefits', 2, None, '___sec34'),
              ('Simple example of unit test', 2, None, '___sec35'),
              ('Simple example of unit test', 2, None, '___sec36'),
              ('"Unit '
               'tests":"https://github.com/philsquared/Catch/blob/master/docs/tutorial.md"',
               2,
               None,
               '___sec37'),
              ('Examples', 2, None, '___sec38'),
              ('Factorial Example', 2, None, '___sec39'),
              ('What did we do (1)?', 2, None, '___sec40'),
              ('What did we do (2)?', 2, None, '___sec41'),
              ('Unit test summary and testing approach', 2, None, '___sec42'),
              ('Coding Recommendations', 2, None, '___sec43'),
              ('Summary and recommendations', 2, None, '___sec44'),
              ('Building a many-body basis', 2, None, '___sec45'),
              ('Building a many-body basis', 2, None, '___sec46'),
              ('Building a many-body basis', 2, None, '___sec47'),
              ('Building a many-body basis', 2, None, '___sec48'),
              ('Building a many-body basis', 2, None, '___sec49'),
              ('Building a many-body basis', 2, None, '___sec50'),
              ('Building a many-body basis', 2, None, '___sec51'),
              ('Building a many-body basis', 2, None, '___sec52'),
              ('Building a many-body basis', 2, None, '___sec53'),
              ('Building a many-body basis', 2, None, '___sec54'),
              ('Building a many-body basis', 2, None, '___sec55'),
              ('Building a many-body basis', 2, None, '___sec56'),
              ('Shell-model project', 2, None, '___sec57'),
              ('Shell-model project', 2, None, '___sec58'),
              ('Shell-model project', 2, None, '___sec59'),
              ('Shell-model project', 2, None, '___sec60'),
              ('Shell-model project', 2, None, '___sec61'),
              ('Shell-model project', 2, None, '___sec62'),
              ('Shell-model project', 2, None, '___sec63'),
              ('Shell-model project', 2, None, '___sec64'),
              ('Shell-model project', 2, None, '___sec65'),
              ('Shell-model project', 2, None, '___sec66'),
              ('Shell-model project', 2, None, '___sec67'),
              ('Shell-model project', 2, None, '___sec68'),
              ('Shell-model project', 2, None, '___sec69'),
              ('Shell-model project', 2, None, '___sec70'),
              ('Shell-model project', 2, None, '___sec71'),
              ('Shell-model project', 2, None, '___sec72'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec73'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec74'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec75'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec76'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec77'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec78'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec79'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec80'),
              ('Example case: pairing Hamiltonian', 2, None, '___sec81'),
              ('Building a Hamiltonian matrix', 2, None, '___sec82'),
              ('Building a Hamiltonian matrix', 2, None, '___sec83'),
              ('Building a Hamiltonian matrix', 2, None, '___sec84'),
              ('Building a Hamiltonian matrix, first step',
               2,
               None,
               '___sec85'),
              ('Building a Hamiltonian matrix, second step',
               2,
               None,
               '___sec86'),
              ('Building a Hamiltonian matrix', 2, None, '___sec87'),
              ('Building a Hamiltonian matrix', 2, None, '___sec88'),
              ('Building a Hamiltonian matrix', 2, None, '___sec89'),
              ('Building a Hamiltonian matrix', 2, None, '___sec90'),
              ('Building a Hamiltonian matrix', 2, None, '___sec91'),
              ('Building a Hamiltonian matrix', 2, None, '___sec92'),
              ('Hamiltonian matrix without the bit representation',
               2,
               None,
               '___sec93'),
              ('Hamiltonian matrix without the bit representation, one and '
               'two-body operators',
               2,
               None,
               '___sec94'),
              ('Strategies for setting up an algorithm', 2, None, '___sec95'),
              ('Computing expectation values and transitions in the '
               'shell-model',
               2,
               None,
               '___sec96'),
              ('Computing expectation values and transitions in the '
               'shell-model and spectroscopic factors',
               2,
               None,
               '___sec97'),
              ('Operators in second quantization', 2, None, '___sec98'),
              ('Operators in second quantization', 2, None, '___sec99'),
              ('Operators in second quantization', 2, None, '___sec100'),
              ('Operators in second quantization', 2, None, '___sec101'),
              ('Operators in second quantization', 2, None, '___sec102'),
              ('Operators in second quantization', 2, None, '___sec103'),
              ('Operators in second quantization', 2, None, '___sec104'),
              ('Operators in second quantization', 2, None, '___sec105'),
              ('Operators in second quantization', 2, None, '___sec106'),
              ('Bit counting', 2, None, '___sec107'),
              ('Eigenvalue problems, basic definitions', 2, None, '___sec108'),
              ('Eigenvalue problems, basic definitions', 2, None, '___sec109'),
              ('Eigenvalue problems, basic definitions', 2, None, '___sec110'),
              ('Abel-Ruffini Impossibility Theorem', 2, None, '___sec111'),
              ('Abel-Ruffini Impossibility Theorem', 2, None, '___sec112'),
              ('Eigenvalue problems, basic definitions', 2, None, '___sec113'),
              ('Eigenvalue problems, basic definitions', 2, None, '___sec114'),
              ('Eigenvalue problems, basic definitions', 2, None, '___sec115'),
              ('Eigenvalue problems, basic definitions', 2, None, '___sec116'),
              ('Discussion of  methods for eigenvalues', 2, None, '___sec117'),
              ('Eigenvalues methods', 2, None, '___sec118'),
              ('Discussion of methods for eigenvalues', 2, None, '___sec119'),
              ("Eigenvalues and Lanczos' method", 2, None, '___sec120'),
              ("Eigenvalues and Lanczos' method, tridiagonal matrix",
               2,
               None,
               '___sec121'),
              ("Eigenvalues and Lanczos' method, tridiagonal and orthogonal "
               'matrices',
               2,
               None,
               '___sec122'),
              ("Eigenvalues and Lanczos' method", 2, None, '___sec123'),
              ("Eigenvalues and Lanczos' method, defining the Lanczos' vectors",
               2,
               None,
               '___sec124'),
              ("Eigenvalues and Lanczos' method, basic steps",
               2,
               None,
               '___sec125')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- ------------------- main content ---------------------- -->

<!-- Slides for PHY981 -->


<center><h1>Full configuration interaction theory</h1></center>  <!-- document title -->

<p>
<!-- author(s): Morten Hjorth-Jensen -->

<center>
<b>Morten Hjorth-Jensen</b> 
</center>

<p>
<!-- institution -->

<center><b><a href="http://www.nscl.msu.edu/" target="_blank">National Superconducting Cyclotron Laboratory</a> and <a href="https://www.pa.msu.edu/" target="_blank">Department of Physics and Astronomy</a>, <a href="http://www.msu.edu/" target="_blank">Michigan State University</a>, East Lansing, MI 48824, USA</b></center>
<br>
<p>
<center><h4>Jul 19, 2018</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec0">Slater determinants as basis states, Repetition </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The simplest possible choice for many-body wavefunctions are <b>product</b> wavefunctions.
That is
$$ 
\Psi(x_1, x_2, x_3, \ldots, x_A) \approx \phi_1(x_1) \phi_2(x_2) \phi_3(x_3) \ldots
$$

because we are really only good  at thinking about one particle at a time. Such 
product wavefunctions, without correlations, are easy to 
work with; for example, if the single-particle states \( \phi_i(x) \) are orthonormal, then 
the product wavefunctions are easy to orthonormalize.

<p>
Similarly, computing matrix elements of operators are relatively easy, because the 
integrals factorize.

<p>
The price we pay is the lack of correlations, which we must build up by using many, many product 
wavefunctions. (Thus we have a trade-off: compact representation of correlations but 
difficult integrals versus easy integrals but many states required.)
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec1">Slater determinants as basis states, repetition </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Because we have fermions, we are required to have antisymmetric wavefunctions, e.g.
$$
\Psi(x_1, x_2, x_3, \ldots, x_A) = - \Psi(x_2, x_1, x_3, \ldots, x_A)
$$

etc. This is accomplished formally by using the determinantal formalism
$$
\Psi(x_1, x_2, \ldots, x_A) 
= \frac{1}{\sqrt{A!}} 
\det \left | 
\begin{array}{cccc}
\phi_1(x_1) & \phi_1(x_2) & \ldots & \phi_1(x_A) \\
\phi_2(x_1) & \phi_2(x_2) & \ldots & \phi_2(x_A) \\
 \vdots & & &  \\
\phi_A(x_1) & \phi_A(x_2) & \ldots & \phi_A(x_A) 
\end{array}
\right |
$$

Product wavefunction + antisymmetry = Slater determinant.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec2">Slater determinants as basis states </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
$$
\Psi(x_1, x_2, \ldots, x_A) 
= \frac{1}{\sqrt{A!}} 
\det \left | 
\begin{array}{cccc}
\phi_1(x_1) & \phi_1(x_2) & \ldots & \phi_1(x_A) \\
\phi_2(x_1) & \phi_2(x_2) & \ldots & \phi_2(x_A) \\
 \vdots & & &  \\
\phi_A(x_1) & \phi_A(x_2) & \ldots & \phi_A(x_A) 
\end{array}
\right |
$$

Properties of the determinant (interchange of any two rows or 
any two columns yields a change in sign; thus no two rows and no 
two columns can be the same) lead to the Pauli principle:

<ul>
<li> No two particles can be at the same place (two columns the same); and</li>
<li> No two particles can be in the same state (two rows the same).</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec3">Slater determinants as basis states </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
As a practical matter, however, Slater determinants beyond \( N=4 \) quickly become 
unwieldy. Thus we turn to the <b>occupation representation</b> or <b>second quantization</b> to simplify calculations.

<p>
The occupation representation or number representation, using fermion <b>creation</b> and <b>annihilation</b> 
operators, is compact and efficient. It is also abstract and, at first encounter, not easy to 
internalize. It is inspired by other operator formalism, such as the ladder operators for 
the harmonic oscillator or for angular momentum, but unlike those cases, the operators <b>do not have coordinate space representations</b>.

<p>
Instead, one can think of fermion creation/annihilation operators as a game of symbols that 
compactly reproduces what one would do, albeit clumsily, with full coordinate-space Slater 
determinants.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec4">Quick repetition of the occupation representation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We start with a set of orthonormal single-particle states \( \{ \phi_i(x) \} \). 
(Note: this requirement, and others, can be relaxed, but leads to a 
more involved formalism.) <b>Any</b> orthonormal set will do.

<p>
To each single-particle state \( \phi_i(x) \) we associate a creation operator 
\( \hat{a}^\dagger_i \) and an annihilation operator \( \hat{a}_i \).

<p>
When acting on the vacuum state \( | 0 \rangle \), the creation operator \( \hat{a}^\dagger_i \) causes 
a particle to occupy the single-particle state \( \phi_i(x) \):
$$
\phi_i(x) \rightarrow \hat{a}^\dagger_i |0 \rangle
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec5">Quick repetition  of the occupation representation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
But with multiple creation operators we can occupy multiple states:
$$
\phi_i(x) \phi_j(x^\prime) \phi_k(x^{\prime \prime}) 
\rightarrow \hat{a}^\dagger_i \hat{a}^\dagger_j \hat{a}^\dagger_k |0 \rangle.
$$

<p>
Now we impose antisymmetry, by having the fermion operators satisfy  <b>anticommutation relations</b>:
$$
\hat{a}^\dagger_i \hat{a}^\dagger_j + \hat{a}^\dagger_j \hat{a}^\dagger_i
= [ \hat{a}^\dagger_i ,\hat{a}^\dagger_j ]_+ 
= \{ \hat{a}^\dagger_i ,\hat{a}^\dagger_j \} = 0
$$

so that 
$$
\hat{a}^\dagger_i \hat{a}^\dagger_j = - \hat{a}^\dagger_j \hat{a}^\dagger_i
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec6">Quick repetition  of the occupation representation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Because of this property, automatically \( \hat{a}^\dagger_i \hat{a}^\dagger_i = 0 \), 
enforcing the Pauli exclusion principle.  Thus when writing a Slater determinant 
using creation operators, 
$$
\hat{a}^\dagger_i \hat{a}^\dagger_j \hat{a}^\dagger_k \ldots |0 \rangle
$$

each index \( i,j,k, \ldots \) must be unique.

<p>
For some relevant exercises with solutions see chapter 8 of <a href="http://www.springer.com/us/book/9783319533353" target="_blank">Lecture Notes in Physics, volume 936</a>.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec7">Full Configuration Interaction Theory </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We have defined the ansatz for the ground state as 
$$
|\Phi_0\rangle = \left(\prod_{i\le F}\hat{a}_{i}^{\dagger}\right)|0\rangle,
$$

where the index \( i \) defines different single-particle states up to the Fermi level. We have assumed that we have \( N \) fermions. 
A given one-particle-one-hole (\( 1p1h \)) state can be written as
$$
|\Phi_i^a\rangle = \hat{a}_{a}^{\dagger}\hat{a}_i|\Phi_0\rangle,
$$

while a \( 2p2h \) state can be written as
$$
|\Phi_{ij}^{ab}\rangle = \hat{a}_{a}^{\dagger}\hat{a}_{b}^{\dagger}\hat{a}_j\hat{a}_i|\Phi_0\rangle,
$$

and a general \( NpNh \) state as 
$$
|\Phi_{ijk\dots}^{abc\dots}\rangle = \hat{a}_{a}^{\dagger}\hat{a}_{b}^{\dagger}\hat{a}_{c}^{\dagger}\dots\hat{a}_k\hat{a}_j\hat{a}_i|\Phi_0\rangle.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec8">Full Configuration Interaction Theory </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We can then expand our exact state function for the ground state 
as
$$
|\Psi_0\rangle=C_0|\Phi_0\rangle+\sum_{ai}C_i^a|\Phi_i^a\rangle+\sum_{abij}C_{ij}^{ab}|\Phi_{ij}^{ab}\rangle+\dots
=(C_0+\hat{C})|\Phi_0\rangle,
$$

where we have introduced the so-called correlation operator 
$$
\hat{C}=\sum_{ai}C_i^a\hat{a}_{a}^{\dagger}\hat{a}_i  +\sum_{abij}C_{ij}^{ab}\hat{a}_{a}^{\dagger}\hat{a}_{b}^{\dagger}\hat{a}_j\hat{a}_i+\dots
$$

Since the normalization of \( \Psi_0 \) is at our disposal and since \( C_0 \) is by hypothesis non-zero, we may arbitrarily set \( C_0=1 \) with 
corresponding proportional changes in all other coefficients. Using this so-called intermediate normalization we have
$$
\langle \Psi_0 | \Phi_0 \rangle = \langle \Phi_0 | \Phi_0 \rangle = 1, 
$$

resulting in 
$$
|\Psi_0\rangle=(1+\hat{C})|\Phi_0\rangle.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec9">Full Configuration Interaction Theory </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We rewrite 
$$
|\Psi_0\rangle=C_0|\Phi_0\rangle+\sum_{ai}C_i^a|\Phi_i^a\rangle+\sum_{abij}C_{ij}^{ab}|\Phi_{ij}^{ab}\rangle+\dots,
$$

in a more compact form as 
$$
|\Psi_0\rangle=\sum_{PH}C_H^P\Phi_H^P=\left(\sum_{PH}C_H^P\hat{A}_H^P\right)|\Phi_0\rangle,
$$

where \( H \) stands for \( 0,1,\dots,n \) hole states and \( P \) for \( 0,1,\dots,n \) particle states. 
Our requirement of unit normalization gives
$$
\langle \Psi_0 | \Phi_0 \rangle = \sum_{PH}|C_H^P|^2= 1,
$$

and the energy can be written as 
$$
E= \langle \Psi_0 | \hat{H} |\Phi_0 \rangle= \sum_{PP'HH'}C_H^{*P}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'}.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec10">Full Configuration Interaction Theory </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Normally 
$$
E= \langle \Psi_0 | \hat{H} |\Phi_0 \rangle= \sum_{PP'HH'}C_H^{*P}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'},
$$

is solved by diagonalization setting up the Hamiltonian matrix defined by the basis of all possible Slater determinants. A diagonalization
<!-- to do: add text about Rayleigh-Ritz -->
is equivalent to finding the variational minimum   of 
$$
 \langle \Psi_0 | \hat{H} |\Phi_0 \rangle-\lambda \langle \Psi_0 |\Phi_0 \rangle,
$$

where \( \lambda \) is a variational multiplier to be identified with the energy of the system.
The minimization process results in 
$$
\delta\left[ \langle \Psi_0 | \hat{H} |\Phi_0 \rangle-\lambda \langle \Psi_0 |\Phi_0 \rangle\right]=
$$

$$
\sum_{P'H'}\left\{\delta[C_H^{*P}]\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'}+
C_H^{*P}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle \delta[C_{H'}^{P'}]-
\lambda( \delta[C_H^{*P}]C_{H'}^{P'}+C_H^{*P}\delta[C_{H'}^{P'}]\right\} = 0.
$$

Since the coefficients \( \delta[C_H^{*P}] \) and \( \delta[C_{H'}^{P'}] \) are complex conjugates it is necessary and sufficient to require the quantities that multiply with \( \delta[C_H^{*P}] \) to vanish.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec11">Full Configuration Interaction Theory </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
This leads to 
$$
\sum_{P'H'}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'}-\lambda C_H^{P}=0,
$$

for all sets of \( P \) and \( H \).

<p>
If we then multiply by the corresponding \( C_H^{*P} \) and sum over \( PH \) we obtain
$$ 
\sum_{PP'HH'}C_H^{*P}\langle \Phi_H^P | \hat{H} |\Phi_{H'}^{P'} \rangle C_{H'}^{P'}-\lambda\sum_{PH}|C_H^P|^2=0,
$$

leading to the identification \( \lambda = E \). This means that we have for all \( PH \) sets
$$
\begin{equation}
\sum_{P'H'}\langle \Phi_H^P | \hat{H} -E|\Phi_{H'}^{P'} \rangle = 0. \label{eq:fullci}
\end{equation}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec12">Full Configuration Interaction Theory </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
An alternative way to derive the last equation is to start from 
$$
(\hat{H} -E)|\Psi_0\rangle = (\hat{H} -E)\sum_{P'H'}C_{H'}^{P'}|\Phi_{H'}^{P'} \rangle=0, 
$$

and if this equation is successively projected against all \( \Phi_H^P \) in the expansion of \( \Psi \), then the last equation on the previous slide
results.   As stated previously, one solves this equation normally by diagonalization. If we are able to solve this equation exactly (that is
numerically exactly) in a large Hilbert space (it will be truncated in terms of the number of single-particle states included in the definition
of Slater determinants), it can then serve as a benchmark for other many-body methods which approximate the correlation operator
\( \hat{C} \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec13">Example of a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Suppose, as an example, that we have six fermions below the Fermi level.
This means that we can make at most \( 6p-6h \) excitations. If we have an infinity of single particle states above the Fermi level, we will obviously have an infinity of say \( 2p-2h \) excitations. Each such way to configure the particles is called a <b>configuration</b>. We will always have to truncate in the basis of single-particle states.
This gives us a finite number of possible Slater determinants. Our Hamiltonian matrix would then look like (where each block can have a large dimensionalities):

<p>
<table border="1">
<thead>
<tr><th align="center">           </th> <td align="center">\( 0p-0h \)</td> <td align="center">\( 1p-1h \)</td> <td align="center">\( 2p-2h \)</td> <td align="center">\( 3p-3h \)</td> <td align="center">\( 4p-4h \)</td> <td align="center">\( 5p-5h \)</td> <td align="center">\( 6p-6h \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   \( 0p-0h \)    </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> </tr>
<tr><td align="center">   \( 1p-1h \)    </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> </tr>
<tr><td align="center">   \( 2p-2h \)    </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   0              </td> <td align="center">   0              </td> </tr>
<tr><td align="center">   \( 3p-3h \)    </td> <td align="center">   0              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   0              </td> </tr>
<tr><td align="center">   \( 4p-4h \)    </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> </tr>
<tr><td align="center">   \( 5p-5h \)    </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> </tr>
<tr><td align="center">   \( 6p-6h \)    </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   0              </td> <td align="center">   x              </td> <td align="center">   x              </td> <td align="center">   x              </td> </tr>
</tbody>
</table>
<p>
with a two-body force. Why are there non-zero blocks of elements?
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Example of a Hamiltonian matrix with a Hartree-Fock basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If we use a Hartree-Fock basis, this corresponds to a particular unitary transformation where matrix elements of the type \( \langle 0p-0h \vert \hat{H} \vert 1p-1h\rangle =\langle \Phi_0 | \hat{H}|\Phi_{i}^{a}\rangle=0 \) and our Hamiltonian matrix becomes

<p>
<table border="1">
<thead>
<tr><th align="center">           </th> <td align="center">  \( 0p-0h \)  </td> <td align="center">  \( 1p-1h \)  </td> <td align="center">  \( 2p-2h \)  </td> <td align="center">  \( 3p-3h \)  </td> <td align="center">  \( 4p-4h \)  </td> <td align="center">  \( 5p-5h \)  </td> <td align="center">  \( 6p-6h \)  </td> </tr>
</thead>
<tbody>
<tr><td align="center">   \( 0p-0h \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   0                  </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   0                  </td> </tr>
<tr><td align="center">   \( 1p-1h \)    </td> <td align="center">   0                  </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   0                  </td> </tr>
<tr><td align="center">   \( 2p-2h \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   0                  </td> <td align="center">   0                  </td> </tr>
<tr><td align="center">   \( 3p-3h \)    </td> <td align="center">   0                  </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   0                  </td> </tr>
<tr><td align="center">   \( 4p-4h \)    </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> </tr>
<tr><td align="center">   \( 5p-5h \)    </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> </tr>
<tr><td align="center">   \( 6p-6h \)    </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   0                  </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> <td align="center">   \( \tilde{x} \)    </td> </tr>
</tbody>
</table>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec15">Shell-model jargon </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If we do not make any truncations in the possible sets of Slater determinants (many-body states) we can make by distributing \( A \) nucleons among \( n \) single-particle states, we call such a calculation for <b>Full configuration interaction theory</b>

<p>
If we make truncations, we have different possibilities

<ul>
<li> The standard nuclear shell-model. Here we define an effective Hilbert space with respect to a given core. The calculations are normally then performed for all many-body states that can be constructed from the effective Hilbert spaces. This approach requires a properly defined effective Hamiltonian</li>
<li> We can truncate in the number of excitations. For example, we can limit the possible Slater determinants to only \( 1p-1h \) and \( 2p-2h \) excitations. This is called a configuration interaction calculation at the level of singles and doubles excitations, or just CISD.</li> 
<li> We can limit the number of excitations in terms of the excitation energies. If we do not define a core, this defines normally what is called the no-core shell-model approach.</li> 
</ul>

What happens if we have a three-body interaction and a Hartree-Fock basis?
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec16">FCI and the exponential growth </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Full configuration interaction theory calculations provide in principle, if we can diagonalize numerically, all states of interest. The dimensionality of the problem explodes however quickly.

<p>
The total number of Slater determinants which can be built with say \( N \) neutrons distributed among \( n \) single particle states is
$$
\left (\begin{array}{c} n \\ N\end{array} \right) =\frac{n!}{(n-N)!N!}. 
$$

<p>
For a model space which comprises the first for major shells only \( 0s \), \( 0p \), \( 1s0d \) and \( 1p0f \) we have \( 40 \) single particle states for neutrons and protons.  For the eight neutrons of oxygen-16 we would then have
$$
\left (\begin{array}{c} 40 \\ 8\end{array} \right) =\frac{40!}{(32)!8!}\sim 10^{9}, 
$$

and multiplying this with the number of proton Slater determinants we end up with approximately with a dimensionality \( d \) of \( d\sim 10^{18} \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec17">Exponential wall </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
This number can be reduced if we look at specific symmetries only. However, the dimensionality explodes quickly!

<ul>
<li> For Hamiltonian matrices of dimensionalities  which are smaller than \( d\sim 10^5 \), we would use so-called direct methods for diagonalizing the Hamiltonian matrix</li>
<li> For larger dimensionalities iterative eigenvalue solvers like Lanczos' method are used. The most efficient codes at present can handle matrices of \( d\sim 10^{10} \).</li> 
</ul>
</div>


<p>
<!-- !split  -->

<h2 id="___sec18">A non-practical way of solving the eigenvalue problem </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
To see this, we look at the contributions arising from 
$$
\langle \Phi_H^P | = \langle \Phi_0|
$$

in  Eq.&nbsp;\eqref{eq:fullci}, that is we multiply with \( \langle \Phi_0 | \)
from the left in 
$$
(\hat{H} -E)\sum_{P'H'}C_{H'}^{P'}|\Phi_{H'}^{P'} \rangle=0. 
$$

If we assume that we have a two-body operator at most, Slater's rule gives then an equation for the 
correlation energy in terms of \( C_i^a \) and \( C_{ij}^{ab} \) only.  We get then
$$
\langle \Phi_0 | \hat{H} -E| \Phi_0\rangle + \sum_{ai}\langle \Phi_0 | \hat{H} -E|\Phi_{i}^{a} \rangle C_{i}^{a}+
\sum_{abij}\langle \Phi_0 | \hat{H} -E|\Phi_{ij}^{ab} \rangle C_{ij}^{ab}=0,
$$

or 
$$
E-E_0 =\Delta E=\sum_{ai}\langle \Phi_0 | \hat{H}|\Phi_{i}^{a} \rangle C_{i}^{a}+
\sum_{abij}\langle \Phi_0 | \hat{H}|\Phi_{ij}^{ab} \rangle C_{ij}^{ab},
$$

where the energy \( E_0 \) is the reference energy and \( \Delta E \) defines the so-called correlation energy.
The single-particle basis functions  could be the results of a Hartree-Fock calculation or just the eigenstates of the non-interacting part of the Hamiltonian.
</div>


<p>
<!-- !split  -->

<h2 id="___sec19">A non-practical way of solving the eigenvalue problem </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
To see this, we look at the contributions arising from 
$$
\langle \Phi_H^P | = \langle \Phi_0|
$$

in  Eq.&nbsp;\eqref{eq:fullci}, that is we multiply with \( \langle \Phi_0 | \)
from the left in 
$$
(\hat{H} -E)\sum_{P'H'}C_{H'}^{P'}|\Phi_{H'}^{P'} \rangle=0. 
$$
</div>


<p>
<!-- !split  -->

<h2 id="___sec20">A non-practical way of solving the eigenvalue problem </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If we assume that we have a two-body operator at most, Slater's rule gives then an equation for the 
correlation energy in terms of \( C_i^a \) and \( C_{ij}^{ab} \) only.  We get then
$$
\langle \Phi_0 | \hat{H} -E| \Phi_0\rangle + \sum_{ai}\langle \Phi_0 | \hat{H} -E|\Phi_{i}^{a} \rangle C_{i}^{a}+
\sum_{abij}\langle \Phi_0 | \hat{H} -E|\Phi_{ij}^{ab} \rangle C_{ij}^{ab}=0,
$$

or 
$$
E-E_0 =\Delta E=\sum_{ai}\langle \Phi_0 | \hat{H}|\Phi_{i}^{a} \rangle C_{i}^{a}+
\sum_{abij}\langle \Phi_0 | \hat{H}|\Phi_{ij}^{ab} \rangle C_{ij}^{ab},
$$

where the energy \( E_0 \) is the reference energy and \( \Delta E \) defines the so-called correlation energy.
The single-particle basis functions  could be the results of a Hartree-Fock calculation or just the eigenstates of the non-interacting part of the Hamiltonian.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec21">Rewriting the FCI equation  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In our notes on Hartree-Fock calculations, 
we have already computed the matrix \( \langle \Phi_0 | \hat{H}|\Phi_{i}^{a}\rangle  \) and \( \langle \Phi_0 | \hat{H}|\Phi_{ij}^{ab}\rangle \).  If we are using a Hartree-Fock basis, then the matrix elements
\( \langle \Phi_0 | \hat{H}|\Phi_{i}^{a}\rangle=0 \) and we are left with a <em>correlation energy</em> given by
$$
E-E_0 =\Delta E^{HF}=\sum_{abij}\langle \Phi_0 | \hat{H}|\Phi_{ij}^{ab} \rangle C_{ij}^{ab}. 
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec22">Rewriting the FCI equation  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Inserting the various matrix elements we can rewrite the previous equation as
$$
\Delta E=\sum_{ai}\langle i| \hat{f}|a \rangle C_{i}^{a}+
\sum_{abij}\langle ij | \hat{v}| ab \rangle C_{ij}^{ab}.
$$

This equation determines the correlation energy but not the coefficients \( C \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec23">Rewriting the FCI equation, does not stop here  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We need more equations. Our next step is to set up
$$
\langle \Phi_i^a | \hat{H} -E| \Phi_0\rangle + \sum_{bj}\langle \Phi_i^a | \hat{H} -E|\Phi_{j}^{b} \rangle C_{j}^{b}+
\sum_{bcjk}\langle \Phi_i^a | \hat{H} -E|\Phi_{jk}^{bc} \rangle C_{jk}^{bc}+
\sum_{bcdjkl}\langle \Phi_i^a | \hat{H} -E|\Phi_{jkl}^{bcd} \rangle C_{jkl}^{bcd}=0,
$$

as this equation will allow us to find an expression for the coefficents \( C_i^a \) since we can rewrite this equation as 
$$
\langle i | \hat{f}| a\rangle +\langle \Phi_i^a | \hat{H}|\Phi_{i}^{a} \rangle C_{i}^{a}+ \sum_{bj\ne ai}\langle \Phi_i^a | \hat{H}|\Phi_{j}^{b} \rangle C_{j}^{b}+
\sum_{bcjk}\langle \Phi_i^a | \hat{H}|\Phi_{jk}^{bc} \rangle C_{jk}^{bc}+
\sum_{bcdjkl}\langle \Phi_i^a | \hat{H}|\Phi_{jkl}^{bcd} \rangle C_{jkl}^{bcd}=EC_i^a.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec24">Rewriting the FCI equation, please stop here  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We see that on the right-hand side we have the energy \( E \). This leads to a non-linear equation in the unknown coefficients. 
These equations are normally solved iteratively ( that is we can start with a guess for the coefficients \( C_i^a \)). A common choice is to use perturbation theory for the first guess, setting thereby
$$
 C_{i}^{a}=\frac{\langle i | \hat{f}| a\rangle}{\epsilon_i-\epsilon_a}.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec25">Rewriting the FCI equation, more to add  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The observant reader will however see that we need an equation for \( C_{jk}^{bc} \) and \( C_{jkl}^{bcd} \) as well.
To find equations for these coefficients we need then to continue our multiplications from the left with the various
\( \Phi_{H}^P \) terms.

<p>
For \( C_{jk}^{bc} \) we need then
$$
\langle \Phi_{ij}^{ab} | \hat{H} -E| \Phi_0\rangle + \sum_{kc}\langle \Phi_{ij}^{ab} | \hat{H} -E|\Phi_{k}^{c} \rangle C_{k}^{c}+
$$

$$
\sum_{cdkl}\langle \Phi_{ij}^{ab} | \hat{H} -E|\Phi_{kl}^{cd} \rangle C_{kl}^{cd}+\sum_{cdeklm}\langle \Phi_{ij}^{ab} | \hat{H} -E|\Phi_{klm}^{cde} \rangle C_{klm}^{cde}+\sum_{cdefklmn}\langle \Phi_{ij}^{ab} | \hat{H} -E|\Phi_{klmn}^{cdef} \rangle C_{klmn}^{cdef}=0,
$$

and we can isolate the coefficients \( C_{kl}^{cd} \) in a similar way as we did for the coefficients \( C_{i}^{a} \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec26">Rewriting the FCI equation, more to add  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
A standard choice for the first iteration is to set 
$$
C_{ij}^{ab} =\frac{\langle ij \vert \hat{v} \vert ab \rangle}{\epsilon_i+\epsilon_j-\epsilon_a-\epsilon_b}.
$$

At the end we can rewrite our solution of the Schroedinger equation in terms of \( n \) coupled equations for the coefficients \( C_H^P \).
This is a very cumbersome way of solving the equation. However, by using this iterative scheme we can illustrate how we can compute the
various terms in the wave operator or correlation operator \( \hat{C} \). We will later identify the calculation of the various terms \( C_H^P \)
as parts of different many-body approximations to full CI. In particular, we can  relate this non-linear scheme with Coupled Cluster theory and
many-body perturbation theory.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec27">Summarizing FCI and bringing in approximative methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
If we can diagonalize large matrices, FCI is the method of choice since:

<ul>
<li> It gives all eigenvalues, ground state and excited states</li>
<li> The eigenvectors are obtained directly from the coefficients \( C_H^P \) which result from the diagonalization</li>
<li> We can compute easily expectation values of other operators, as well as transition probabilities</li>
<li> Correlations are easy to understand in terms of contributions to a given operator beyond the Hartree-Fock contribution. This is the standard approach in  many-body theory.</li> 
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec28">Definition of the correlation energy  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The correlation energy is defined as, with a two-body Hamiltonian,  
$$
\Delta E=\sum_{ai}\langle i| \hat{f}|a \rangle C_{i}^{a}+
\sum_{abij}\langle ij | \hat{v}| ab \rangle C_{ij}^{ab}.
$$

The coefficients \( C \) result from the solution of the eigenvalue problem. 
The energy of say the ground state is then
$$
E=E_{ref}+\Delta E,
$$

where the so-called reference energy is the energy we obtain from a Hartree-Fock calculation, that is
$$
E_{ref}=\langle \Phi_0 \vert \hat{H} \vert \Phi_0 \rangle.
$$


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec29">FCI equation and the coefficients  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
However, as we have seen, even for a small case like the four first major shells and a nucleus like oxygen-16, the dimensionality becomes quickly intractable. If we wish to include single-particle states that reflect weakly bound systems, we need a much larger single-particle basis. We need thus approximative methods that sum specific correlations to infinite order.

<p>
Popular methods are

<ul>
<li> <a href="http://www.sciencedirect.com/science/article/pii/0370157395000126" target="_blank">Many-body perturbation theory (in essence a Taylor expansion)</a></li>
<li> <a href="http://iopscience.iop.org/article/10.1088/0034-4885/77/9/096302/meta" target="_blank">Coupled cluster theory (coupled non-linear equations)</a></li>
<li> Green's function approaches (matrix inversion)</li>
<li> <a href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.106.222502" target="_blank">Similarity group transformation methods (coupled ordinary differential equations)</a></li>
</ul>

All these methods start normally with a Hartree-Fock basis as the calculational basis.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec30">Important ingredients to have in codes </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<ul>
<li> Be able to validate and verify  the  algorithms.</li> 
<li> Include concepts like unit testing. Gives the possibility to test and validate several or all parts of the code.</li>
<li> Validation and verification are then included <em>naturally</em> and one can develop a better attitude to what is meant with an ethically sound scientific approach.</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec31">A structured approach to solving problems </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In the steps that lead to the development of clean code you should  think of 

<ol>
  <li> How to structure a code in terms of functions  (use IDEs or advanced text editors like sublime or atom)</li>
  <li> How to make a module</li>
  <li> How to read input data flexibly from the command line or files</li>
  <li> How to create graphical/web user interfaces</li>
  <li> How to write unit tests</li>  
  <li> How to refactor code in terms of classes (instead of functions only)</li>
  <li> How to conduct and automate large-scale numerical experiments</li>
  <li> How to write scientific reports in various formats (LaTeX, HTML, doconce)</li>
</ol>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec32">Additional benefits  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Many of the above aspetcs  will save you a lot of time when you incrementally extend software over time from simpler to more complicated problems. In particular, you will benefit from many good habits:

<ol>
<li> New code is added in a modular fashion to a library (modules)</li>
<li> Programs are run through convenient user interfaces</li>
<li> It takes one quick command to let all your code undergo heavy testing</li> 
<li> Tedious manual work with running programs is automated,</li>
<li> Your scientific investigations are reproducible, scientific reports with top quality typesetting are produced both for paper and electronic devices. Use version control software like <a href="https://git-scm.com/" target="_blank">git</a> and repositories like <a href="https://github.com/" target="_blank">github</a></li>
</ol>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec33">Unit Testing </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Unit Testing is the practice of testing the smallest testable parts,
called units, of an application individually and independently to
determine if they behave exactly as expected.

<p>
Unit tests (short code
fragments) are usually written such that they can be preformed at any
time during the development to continually verify the behavior of the
code.

<p>
In this way, possible bugs will be identified early in the
development cycle, making the debugging at later stages much
easier.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec34">Unit Testing, benefits </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
There are many benefits associated with Unit Testing, such as

<ul>
  <li> It increases confidence in changing and maintaining code. Big changes can be made to the code quickly, since the tests will ensure that everything still is working properly.</li>
  <li> Since the code needs to be modular to make Unit Testing possible, the code will be easier to reuse. This improves the code design.</li>
  <li> Debugging is easier, since when a test fails, only the latest changes need to be debugged.</li>

<ul>
   <li> Different parts of a project can be tested without the need to wait for the other parts to be available.</li>
</ul>

  <li> A unit test can serve as a documentation on the functionality of a unit of the code.</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec35">Simple example of unit test </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Look up the guide on how to install unit tests for c++ at course webpage. This is the version with classes.
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span></span><span style="color: #1e889b">#include</span> <span style="color: #228B22">&lt;unittest++/UnitTest++.h&gt;</span><span style="color: #1e889b"></span>

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">MyMultiplyClass</span>{
<span style="color: #8B008B; font-weight: bold">public</span>:
    <span style="color: #00688B; font-weight: bold">double</span> multiply(<span style="color: #00688B; font-weight: bold">double</span> x, <span style="color: #00688B; font-weight: bold">double</span> y) {
        <span style="color: #8B008B; font-weight: bold">return</span> x * y;
    }
};

TEST(MyMath) {
    MyMultiplyClass my;
    CHECK_EQUAL(<span style="color: #B452CD">56</span>, my.multiply(<span style="color: #B452CD">7</span>,<span style="color: #B452CD">8</span>));
}

<span style="color: #00688B; font-weight: bold">int</span> main()
{
    <span style="color: #8B008B; font-weight: bold">return</span> UnitTest::RunAllTests();
}
</pre></div>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec36">Simple example of unit test </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
And without classes
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span></span><span style="color: #1e889b">#include</span> <span style="color: #228B22">&lt;unittest++/UnitTest++.h&gt;</span><span style="color: #1e889b"></span>


<span style="color: #00688B; font-weight: bold">double</span> <span style="color: #008b45">multiply</span>(<span style="color: #00688B; font-weight: bold">double</span> x, <span style="color: #00688B; font-weight: bold">double</span> y) {
    <span style="color: #8B008B; font-weight: bold">return</span> x * y;
}

TEST(MyMath) {
    CHECK_EQUAL(<span style="color: #B452CD">56</span>, multiply(<span style="color: #B452CD">7</span>,<span style="color: #B452CD">8</span>));
}

<span style="color: #00688B; font-weight: bold">int</span> main()
{
    <span style="color: #8B008B; font-weight: bold">return</span> UnitTest::RunAllTests();
} 
</pre></div>
<p>
For Fortran users, the link at <a href="http://sourceforge.net/projects/fortranxunit/" target="_blank"><tt>http://sourceforge.net/projects/fortranxunit/</tt></a> contains a similar
software for unit testing. For Python go to <a href="https://docs.python.org/2/library/unittest.html" target="_blank"><tt>https://docs.python.org/2/library/unittest.html</tt></a>.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec37"><a href="https://github.com/philsquared/Catch/blob/master/docs/tutorial.md" target="_blank">Unit tests</a>  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
There are many types of <b>unit test</b> libraries. One which is very popular with C++ programmers is <a href="https://github.com/philsquared/Catch/blob/master/docs/tutorial.md" target="_blank">Catch</a>

<p>
Catch is header only. All you need to do is drop the file(s) somewhere reachable from your project - either in some central location you can set your header search path to find, or directly into your project tree itself!

<p>
This is a particularly good option for other Open-Source projects that want to use Catch for their test suite.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec38">Examples </h2>

<p>
Computing factorials
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">inline</span> <span style="color: #00688B; font-weight: bold">unsigned</span> <span style="color: #00688B; font-weight: bold">int</span> <span style="color: #008b45">Factorial</span>( <span style="color: #00688B; font-weight: bold">unsigned</span> <span style="color: #00688B; font-weight: bold">int</span> number ) {
  <span style="color: #8B008B; font-weight: bold">return</span> number &gt; <span style="color: #B452CD">1</span> ? Factorial(number-<span style="color: #B452CD">1</span>)*number : <span style="color: #B452CD">1</span>;
}
</pre></div>
<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec39">Factorial Example </h2>

<p>
Simple test where we put everything in a single file

<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #1e889b">#define CATCH_CONFIG_MAIN  </span><span style="color: #228B22">// This tells Catch to provide a main()</span>
<span style="color: #1e889b">#include</span> <span style="color: #228B22">&quot;catch.hpp&quot;</span><span style="color: #1e889b"></span>
<span style="color: #8B008B; font-weight: bold">inline</span> <span style="color: #00688B; font-weight: bold">unsigned</span> <span style="color: #00688B; font-weight: bold">int</span> <span style="color: #008b45">Factorial</span>( <span style="color: #00688B; font-weight: bold">unsigned</span> <span style="color: #00688B; font-weight: bold">int</span> number ) {
  <span style="color: #8B008B; font-weight: bold">return</span> number &gt; <span style="color: #B452CD">1</span> ? Factorial(number-<span style="color: #B452CD">1</span>)*number : <span style="color: #B452CD">1</span>;
}

TEST_CASE( <span style="color: #CD5555">&quot;Factorials are computed&quot;</span>, <span style="color: #CD5555">&quot;[factorial]&quot;</span> ) {
    REQUIRE( Factorial(<span style="color: #B452CD">0</span>) == <span style="color: #B452CD">1</span> );
    REQUIRE( Factorial(<span style="color: #B452CD">1</span>) == <span style="color: #B452CD">1</span> );
    REQUIRE( Factorial(<span style="color: #B452CD">2</span>) == <span style="color: #B452CD">2</span> );
    REQUIRE( Factorial(<span style="color: #B452CD">3</span>) == <span style="color: #B452CD">6</span> );
    REQUIRE( Factorial(<span style="color: #B452CD">10</span>) == <span style="color: #B452CD">3628800</span> );
}
</pre></div>
<p>
This will compile to a complete executable which responds to command line arguments. If you just run it with no arguments it will execute all test cases (in this case there is just one), report any failures, report a summary of how many tests passed and failed and return the number of failed tests.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec40">What did we do (1)? </h2>
All we did was 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #1e889b">#define </span>
</pre></div>
<p>
one identifier and 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #1e889b">#include</span><span style="color: #228B22"> </span><span style="color: #1e889b"></span>
</pre></div>
<p>
one header and we got everything - even an implementation of main() that will respond to command line arguments. 
Once you have more than one file with unit tests in you'll just need to 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #1e889b">#include</span> <span style="color: #228B22">&quot;catch.hpp&quot; </span><span style="color: #1e889b"></span>
</pre></div>
<p>
and go. Usually it's a good idea to have a dedicated implementation file that just has 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span><span style="color: #1e889b">#define CATCH_CONFIG_MAIN </span>
<span style="color: #1e889b">#include</span> <span style="color: #228B22">&quot;catch.hpp&quot;. </span><span style="color: #1e889b"></span>
</pre></div>
<p>
You can also provide your own implementation of main and drive Catch yourself.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec41">What did we do (2)? </h2>
We introduce test cases with the 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>TEST_CASE 
</pre></div>
<p>
macro.

<p>
The test name must be unique. You can run sets of tests by specifying a wildcarded test name or a tag expression. 
All we did was <b>define</b> one identifier and <b>include</b> one header and we got everything.

<p>
We write our individual test assertions using the 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span></span>REQUIRE 
</pre></div>
<p>
macro.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec42">Unit test summary and testing approach </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Three levels of tests

<ol>
<li> Microscopic level: testing small parts of code, use often unit test libraries</li>
<li> Mesoscopic level: testing the integration of various parts  of your code</li>
<li> Macroscopic level: testing that the final result is ok</li>
</ol>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec43">Coding Recommendations  </h2>
Writing clean and clear code is an art and reflects 
your understanding of 

<ol>
<li> derivation, verification, and implementation of algorithms</li>
<li> what can go wrong with algorithms</li>
<li> overview of important, known algorithms</li>
<li> how algorithms are used to solve mathematical problems</li>
<li> reproducible science and ethics</li>
<li> algorithmic thinking for gaining deeper insights about scientific problems</li>
</ol>

Computing is understanding and your understanding is reflected in your abilities to
write clear and clean code.

<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec44">Summary and recommendations  </h2>
Some simple hints and tips in order to write clean and clear code

<ol>
<li> Spell out the algorithm and have a top-down approach to the flow of data</li>
<li> Start with coding as close as possible to eventual mathematical expressions</li>
<li> Use meaningful names for variables</li>
<li> Split tasks in simple functions and modules/classes</li>
<li> Functions should return as few as possible variables</li>
<li> Use unit tests and make sure your codes are producing the correct results</li>
<li> Where possible use symbolic coding to autogenerate code and check results</li>
<li> Make a proper timing of your algorithms</li>
<li> Use version control and make your science reproducible</li>
<li> Use IDEs or smart editors with debugging and analysis tools.</li>
<li> Automatize your computations interfacing high-level and compiled languages like C++ and Fortran.</li>
<li> .....</li>
</ol>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec45">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Here we will discuss how we can set up a single-particle basis which we can use in the various parts of our projects, from the simple pairing model to infinite nuclear matter. We will use here the simple pairing model to illustrate in particular how to set up a single-particle basis. We will also use this do discuss standard FCI approaches like:

<ol>
 <li> Standard shell-model basis in one or two major shells</li>
 <li> Full CI in a given basis and no truncations</li>
 <li> CISD and CISDT approximations</li>
 <li> No-core shell model and truncation in excitation energy</li>
</ol>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec46">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
An important step in an FCI code  is to construct the many-body basis.

<p>
While the formalism is independent of the choice of basis, the <b>effectiveness</b> of a calculation 
will certainly be basis dependent.

<p>
Furthermore there are common conventions useful to know.

<p>
First, the single-particle basis has angular momentum as a good quantum number.  You can 
imagine the single-particle wavefunctions being generated by a one-body Hamiltonian, 
for example a harmonic oscillator.  Modifications include harmonic oscillator plus 
spin-orbit splitting, or self-consistent mean-field potentials, or the Woods-Saxon potential which mocks 
up the self-consistent mean-field. 
For nuclei, the harmonic oscillator, modified by spin-orbit splitting, provides a useful language 
for describing single-particle states.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec47">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Each single-particle state is labeled by the following quantum numbers: 

<ul>
<li> Orbital angular momentum \( l \)</li>
<li> Intrinsic spin \( s \) = 1/2 for protons and neutrons</li>
<li> Angular momentum \( j = l \pm 1/2 \)</li>
<li> \( z \)-component \( j_z \) (or \( m \))</li>
<li> Some labeling of the radial wavefunction, typically \( n \) the number of nodes in  the radial wavefunction, but in the case of harmonic oscillator one can also use the principal quantum number \( N \), where the harmonic oscillator energy is \( (N+3/2)\hbar \omega \).</li>  
</ul>

In this format one labels states by \( n(l)_j \), with \( (l) \) replaced by a letter:
\( s \) for \( l=0 \), \( p \) for \( l=1 \), \( d \) for \( l=2 \), \( f \) for \( l=3 \), and thenceforth alphabetical.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec48">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
 In practice the single-particle space has to be severely truncated.  This truncation is 
typically based upon the single-particle energies, which is the effective energy 
from a mean-field potential.

<p>
Sometimes we freeze the core and only consider a valence space. For example, one 
may assume a frozen \( {}^{4}\mbox{He} \) core, with two protons and two neutrons in the \( 0s_{1/2} \) 
shell, and then only allow active particles in the \( 0p_{1/2} \) and \( 0p_{3/2} \) orbits.

<p>
Another example is a frozen \( {}^{16}\mbox{O} \) core, with eight protons and eight neutrons filling the 
\( 0s_{1/2} \),  \( 0p_{1/2} \) and \( 0p_{3/2} \) orbits, with valence particles in the 
\( 0d_{5/2}, 1s_{1/2} \) and \( 0d_{3/2} \) orbits.

<p>
Sometimes we refer to nuclei by the valence space where their last nucleons go.  
So, for example, we call \( {}^{12}\mbox{C} \) a \( p \)-shell nucleus, while \( {}^{26}\mbox{Al} \) is an 
\( sd \)-shell nucleus and \( {}^{56}\mbox{Fe} \) is a \( pf \)-shell nucleus.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec49">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
There are different kinds of truncations.

<ul>
<li> For example, one can start with `filled' orbits (almost always the lowest), and then  allow one, two, three... particles excited out of those filled orbits. These are called  1p-1h, 2p-2h, 3p-3h excitations.</li> 
<li> Alternately, one can state a maximal orbit and allow all possible configurations with  particles occupying states up to that maximum. This is called <em>full configuration</em>.</li>
<li> Finally, for particular use in nuclear physics, there is the <em>energy</em> truncation, also  called the \( N\hbar\Omega \) or \( N_{max} \) truncation.</li> 
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec50">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Here one works in a harmonic oscillator basis, with each major oscillator shell assigned  a principal quantum number \( N=0,1,2,3,... \). 
The \( N\hbar\Omega \) or \( N_{max} \) truncation: Any configuration is given an noninteracting energy, which is the sum 
of the single-particle harmonic oscillator energies. (Thus this ignores 
spin-orbit splitting.)

<p>
Excited state are labeled relative to the lowest configuration by the 
number of harmonic oscillator quanta.

<p>
This truncation is useful because if one includes <em>all</em> configuration up to 
some \( N_{max} \), and has a translationally invariant interaction, then the intrinsic 
motion and the center-of-mass motion factor. In other words, we can know exactly 
the center-of-mass wavefunction.

<p>
In almost all cases, the many-body Hamiltonian is rotationally invariant. This means 
it commutes with the operators \( \hat{J}^2, \hat{J}_z \) and so eigenstates will have 
good \( J,M \). Furthermore, the eigenenergies do not depend upon the orientation \( M \).

<p>
Therefore we can choose to construct a many-body basis which has fixed \( M \); this is 
called an \( M \)-scheme basis.

<p>
Alternately, one can construct a many-body basis which has fixed \( J \), or a \( J \)-scheme 
basis.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec51">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The Hamiltonian matrix will have smaller dimensions (a factor of 10 or more) in the \( J \)-scheme than in the \( M \)-scheme. 
On the other hand, as we'll show in the next slide, the \( M \)-scheme is very easy to 
construct with Slater determinants, while the \( J \)-scheme basis states, and thus the 
matrix elements, are more complicated, almost always being linear combinations of 
\( M \)-scheme states. \( J \)-scheme bases are important and useful, but we'll focus on the 
simpler \( M \)-scheme.

<p>
The quantum number \( m \) is additive (because the underlying group is Abelian): 
if a Slater determinant \( \hat{a}_i^\dagger \hat{a}^\dagger_j \hat{a}^\dagger_k \ldots | 0 \rangle \) 
is built from single-particle states all with good \( m \), then the total 
$$
M = m_i + m_j + m_k + \ldots
$$

This is <em>not</em> true of \( J \), because the angular momentum group SU(2) is not Abelian.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec52">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
The upshot is that 

<ul>
<li> It is easy to construct a Slater determinant with good total \( M \);</li>
<li> It is trivial to calculate \( M \) for each Slater determinant;</li>
<li> So it is easy to construct an \( M \)-scheme basis with fixed total \( M \).</li>
</ul>

Note that the individual \( M \)-scheme basis states will <em>not</em>, in general, 
have good total \( J \). 
Because the Hamiltonian is rotationally invariant, however, the eigenstates will 
have good \( J \). (The situation is muddied when one has states of different \( J \) that are 
nonetheless degenerate.)
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec53">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Example: two \( j=1/2 \) orbits

<p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <td align="center">\( n \)</td> <td align="center">\( l \)</td> <td align="center">\( j \)</td> <td align="center">\( m_j \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
</tbody>
</table>
<p>
Note that the order is arbitrary.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec54">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
There are \( \left ( \begin{array}{c} 4 \\ 2 \end{array} \right) = 6 \) two-particle states, 
which we list with the total \( M \):

<p>
<table border="1">
<thead>
<tr><th align="center">Occupied</th> <td align="center">\( M \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1,2         </td> <td align="center">   0          </td> </tr>
<tr><td align="center">   1,3         </td> <td align="center">   -1         </td> </tr>
<tr><td align="center">   1,4         </td> <td align="center">   0          </td> </tr>
<tr><td align="center">   2,3         </td> <td align="center">   0          </td> </tr>
<tr><td align="center">   2,4         </td> <td align="center">   1          </td> </tr>
<tr><td align="center">   3,4         </td> <td align="center">   0          </td> </tr>
</tbody>
</table>
There are 4 states with \( M= 0 \), 
and 1 each with \( M = \pm 1 \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec55">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
As another example, consider using only single particle states from the \( 0d_{5/2} \) space. 
They have the following quantum numbers

<p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <td align="center">\( n \)</td> <td align="center">\( l \)</td> <td align="center">\( j \)</td> <td align="center">\( m_j \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   -5/2         </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   -3/2         </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   3/2          </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   5/2          </td> </tr>
</tbody>
</table>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec56">Building a many-body basis </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
There are \( \left ( \begin{array}{c} 6 \\ 2 \end{array} \right) = 15 \) two-particle states, 
which we list with the total \( M \):

<p>
<table border="1">
<thead>
<tr><th align="center">Occupied</th> <td align="center">\( M \)</td> <th align="center">Occupied</th> <td align="center">\( M \)</td> <th align="center">Occupied</th> <td align="center">\( M \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1,2         </td> <td align="center">   -4         </td> <td align="center">   2,3         </td> <td align="center">   -2         </td> <td align="center">   3,5         </td> <td align="center">   1          </td> </tr>
<tr><td align="center">   1,3         </td> <td align="center">   -3         </td> <td align="center">   2,4         </td> <td align="center">   -1         </td> <td align="center">   3,6         </td> <td align="center">   2          </td> </tr>
<tr><td align="center">   1,4         </td> <td align="center">   -2         </td> <td align="center">   2,5         </td> <td align="center">   0          </td> <td align="center">   4,5         </td> <td align="center">   2          </td> </tr>
<tr><td align="center">   1,5         </td> <td align="center">   -1         </td> <td align="center">   2,6         </td> <td align="center">   1          </td> <td align="center">   4,6         </td> <td align="center">   3          </td> </tr>
<tr><td align="center">   1,6         </td> <td align="center">   0          </td> <td align="center">   3,4         </td> <td align="center">   0          </td> <td align="center">   5,6         </td> <td align="center">   4          </td> </tr>
</tbody>
</table>
<p>
There are 3 states with \( M= 0 \), 2 with \( M = 1 \), and so on.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec57">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
The first step  is to construct the \( M \)-scheme basis of Slater determinants.
Here \( M \)-scheme means the total \( J_z \) of the many-body states is fixed.

<p>
The steps could be:

<ul>
<li> Read in a user-supplied file of single-particle states (examples can be given) or just code these internally;</li>
<li> Ask for the total \( M \) of the system and the number of particles \( N \);</li>
<li> Construct all the \( N \)-particle states with given \( M \).  You will validate the code by  comparing both the number of states and specific states.</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec58">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The format of a possible input  file could be
<table border="1">
<thead>
<tr><th align="center">Index</th> <td align="center">\( n \)</td> <td align="center">\( l \)</td> <td align="center">\( 2j \)</td> <td align="center">\( 2m_j \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1           </td> <td align="center">   -1            </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1           </td> <td align="center">   1             </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   3           </td> <td align="center">   -3            </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   3           </td> <td align="center">   -1            </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   3           </td> <td align="center">   1             </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   3           </td> <td align="center">   3             </td> </tr>
<tr><td align="center">   7        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5           </td> <td align="center">   -5            </td> </tr>
<tr><td align="center">   8        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5           </td> <td align="center">   -3            </td> </tr>
<tr><td align="center">   9        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5           </td> <td align="center">   -1            </td> </tr>
<tr><td align="center">   10       </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5           </td> <td align="center">   1             </td> </tr>
<tr><td align="center">   11       </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5           </td> <td align="center">   3             </td> </tr>
<tr><td align="center">   12       </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5           </td> <td align="center">   5             </td> </tr>
</tbody>
</table>
<p>
This represents the \( 1s_{1/2}0d_{3/2}0d_{5/2} \) valence space, or just the \( sd \)-space.  There are 
twelve single-particle states, labeled by an overall index, and which have associated quantum 
numbers the number of radial nodes, the orbital angular momentum \( l \), and the 
angular momentum \( j \) and third component \( j_z \).  To keep everything as integers, we could store \( 2 \times j \) and 
\( 2 \times j_z \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec59">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
To read in the single-particle states you need to:

<ul>
<li> Open the file</li> 

<ul>
 <li> Read the number of single-particle states (in the above example, 12);  allocate memory; all you need is a single array storing \( 2\times j_z \) for each state, labeled by the index.</li>
</ul>

<li> Read in the quantum numbers and store \( 2 \times j_z \) (and anything else you happen to want).</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec60">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
The next step is to read in the number of particles \( N \) and the fixed total \( M \) (or, actually, \( 2 \times M \)). 
For this project we assume only a single species of particles, say neutrons, although this can be 
relaxed. <b>Note</b>: Although it is often a good idea to try to write a more general code, given the 
short time alloted we would suggest you keep your ambition in check, at least in the initial phases of the 
project.

<p>
You should probably write an error trap to make sure \( N \) and \( M \) are congruent; if \( N \) is even, then 
\( 2 \times M \) should be even, and if \( N \) is odd then \( 2\times M \) should be odd.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec61">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The final step is to generate the set of \( N \)-particle Slater determinants with fixed \( M \). 
The Slater determinants will be stored in occupation representation.  Although in many codes
this representation is done compactly in bit notation with ones and zeros, but for 
greater transparency and simplicity we will list the occupied single particle states.

<p>
 Hence we can 
store the Slater determinant basis states as \( sd(i,j) \), that is an 
array of dimension \( N_{SD} \), the number of Slater determinants, by \( N \), the number of occupied 
state. So if for the 7th Slater determinant the 2nd, 3rd, and 9th single-particle states are occupied, 
then \( sd(7,1) = 2 \), \( sd(7,2) = 3 \), and \( sd(7,3) = 9 \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec62">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
We can construct an occupation representation of Slater determinants by the <em>odometer</em>
method.  Consider \( N_{sp} = 12 \) and \( N=4 \). 
Start with the first 4 states occupied, that is:

<ul>
<li> \( sd(1,:)= 1,2,3,4 \) (also written as \( |1,2,3,4 \rangle \))</li>
</ul>

Now increase the last occupancy recursively:

<ul>
<li> \( sd(2,:)= 1,2,3,5 \)</li>
<li> \( sd(3,:)= 1,2,3,6 \)</li>
<li> \( sd(4,:)= 1,2,3,7 \)</li>
<li> \( \ldots \)</li>
<li> \( sd(9,:)= 1,2,3,12 \)</li>
</ul>

Then start over with 

<ul>
<li> \( sd(10,:)= 1,2,4,5 \)</li>
</ul>

and again increase the rightmost digit

<ul>
<li> \( sd(11,:)= 1,2,4,6 \)</li>
<li> \( sd(12,:)= 1,2,4,7 \)</li>
<li> \( \ldots \)</li>
<li> \( sd(17,:)= 1,2,4,12 \)</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec63">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
When we restrict ourselves to an \( M \)-scheme basis, we could choose two paths. 
The first is simplest (and simplest is often best, at 
least in the first draft of a code): generate all possible Slater determinants, 
and then extract from this initial list a list of those Slater determinants with a given 
\( M \). (You will need to write a short function or routine that computes \( M \) for any 
given occupation.)

<p>
Alternately, and not too difficult, is to run the odometer routine twice: each time, as 
as a Slater determinant is calculated, compute \( M \), but do not store the Slater determinants 
except the current one. You can then count up the number of Slater determinants with a 
chosen \( M \).  Then allocated storage for the Slater determinants, and run the odometer 
algorithm again, this time storing Slater determinants with the desired \( M \) (this can be 
done with a simple logical flag).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec64">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
<em>Some example solutions</em>:  Let's begin with a simple case, the \( 0d_{5/2} \) space containing six single-particle states

<p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <td align="center">\( n \)</td> <td align="center">\( l \)</td> <td align="center">\( j \)</td> <td align="center">\( m_j \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   -5/2         </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   -3/2         </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   3/2          </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   0          </td> <td align="center">   2          </td> <td align="center">   5/2        </td> <td align="center">   5/2          </td> </tr>
</tbody>
</table>
<p>
For two particles, there are a total of 15 states, which we list here with the total \( M \):

<ul>
<li> \( \vert 1,2 \rangle \), \( M= -4 \),  \( \vert 1,3 \rangle \), \( M= -3 \)</li>
<li> \( \vert  1,4 \rangle \), \( M= -2 \), \( \vert 1,5 \rangle \), \( M= -1 \)</li>
<li> \( \vert 1,5 \rangle \), \( M= 0 \), \( vert 2,3 \rangle \), \( M= -2 \)</li>
<li> \( \vert 2,4 \rangle \), \( M= -1 \), \( \vert 2,5 \rangle \), \( M= 0 \)</li>
<li> \( \vert 2,6 \rangle \), \( M= 1 \), \( \vert 3,4 \rangle \), \( M= 0 \)</li>
<li> \( \vert 3,5 \rangle \), \( M= 1 \), \( \vert 3,6 \rangle \), \( M= 2 \)</li>
<li> \( \vert 4,5 \rangle \), \( M= 2 \), \( \vert 4,6 \rangle \), \( M= 3 \)</li>
<li> \( \vert 5,6 \rangle \), \( M= 4 \)</li>
</ul>

Of these, there are only 3 states with \( M=0 \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec65">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<em>You should try</em> by hand to show that in this same single-particle space, that for 
\( N=3 \) there are 3 states with \( M=1/2 \) and for \( N= 4 \) there are also only 3 states with \( M=0 \).

<p>
<em>To test your code</em>, confirm the above.

<p>
Also, 
for the \( sd \)-space given above, for \( N=2 \) there are 14 states with \( M=0 \), for \( N=3 \) there are 37 
states with \( M=1/2 \), for \( N=4 \) there are 81 states with \( M=0 \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec66">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
For our project, we will only consider the pairing model.
A simple space is the \( (1/2)^2 \) space with four single-particle states

<p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <td align="center">\( n \)</td> <td align="center">\( l \)</td> <td align="center">\( s \)</td> <td align="center">\( m_s \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
</tbody>
</table>
<p>
For \( N=2 \) there are 4 states with \( M=0 \); show this by hand and confirm your code reproduces it.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec67">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Another, slightly more challenging space is the \( (1/2)^4 \) space, that is, 
with eight  single-particle states we have

<p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <td align="center">\( n \)</td> <td align="center">\( l \)</td> <td align="center">\( s \)</td> <td align="center">\( m_s \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   2          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   2          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   7        </td> <td align="center">   3          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   8        </td> <td align="center">   3          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
</tbody>
</table>
<p>
For \( N=2 \) there are 16 states with \( M=0 \); for \( N=3 \) there are 24 states with \( M=1/2 \), and for 
\( N=4 \) there are 36 states with \( M=0 \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec68">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In the shell-model context we can interpret this as 4 \( s_{1/2} \) levels, with \( m = \pm 1/2 \), we can also think of these are simple four pairs,  \( \pm k, k = 1,2,3,4 \). Later on we will 
assign single-particle energies,  depending on the radial quantum number \( n \), that is, 
\( \epsilon_k = |k| \delta \) so that they are equally spaced.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec69">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
For application in the pairing model we can go further and consider only states with 
no &quot;broken pairs,&quot; that is, if \( +k \) is filled (or \( m = +1/2 \), so is \( -k \) (\( m=-1/2 \)). 
If you want, you can write your code to accept only these, and obtain the following 
six states:

<ul>
<li> \( |           1,           2 ,          3         ,       4  \rangle ,  \)</li>
<li> \( |            1      ,     2        ,        5         ,       6 \rangle ,  \)</li>
<li> \( |            1         ,       2     ,           7         ,       8  \rangle ,  \)</li>
<li> \( |            3        ,        4      ,          5          ,      6  \rangle ,  \)</li>
<li> \( |            3        ,        4      ,          7         ,       8  \rangle ,  \)</li>
<li> \( |            5        ,        6     ,           7     ,           8  \rangle  \)</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec70">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>Hints for coding.</b>
<p>

<ul>
<li> Write small modules (routines/functions) ; avoid big functions  that do everything. (But not too small.)</li>
<li> Use Unit tests! Write lots of error traps, even for things that are `obvious.'</li>
<li> Document as you go along. The Unit tests serve as documentation. For each function write a header that includes: 

<ol type="a"></li>
<li> Main purpose of function and/or unit test</li>
<li> names and  brief explanation of input variables, if any</li> 
<li> names and brief explanation of output variables, if any</li>
<li> functions called by this function</li>
<li> called by which functions</li>
</ol>

</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec71">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Hints for coding

<ul>
<li> Unit tests will save time. Use also IDEs for debugging. If you insist on brute force debugging, print out intermediate values. It's almost impossible to debug a  code by looking at it&ndash;the code will almost always win a `staring contest.'</li>
<li> Validate code with SIMPLE CASES. Validate early and often.  Unit tests!!</li> 
</ul>

The number one mistake is using a too complex a system to test. For example ,
if you are computing particles in a potential in a box, try removing the potential&ndash;you should get 
particles in a box. And start with one particle, then two, then three... Don't start with 
eight particles.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec72">Shell-model project  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Our recommended occupation representation, e.g. \( | 1,2,4,8 \rangle \), is 
easy to code, but numerically inefficient when one has hundreds of 
millions of Slater determinants.

<p>
In state-of-the-art shell-model codes, one generally uses bit 
representation, i.e. \( |1101000100... \rangle \) where one stores 
the Slater determinant as a single (or a small number of) integer.

<p>
This is much more compact, but more intricate to code with considerable 
more overhead. There exist 
bit-manipulation functions. We will discuss these in more detail at the beginning of the third week.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec73">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
We consider a space with \( 2\Omega \) single-particle states, with each 
state labeled by 
\( k = 1, 2, 3, \Omega \) and \( m = \pm 1/2 \). The convention is that 
the state with \( k>0 \) has \( m = + 1/2 \) while \( -k \) has \( m = -1/2 \).

<p>
The Hamiltonian we consider is 
$$
\hat{H} = -G \hat{P}_+ \hat{P}_-,
$$

where
$$
\hat{P}_+ = \sum_{k > 0} \hat{a}^\dagger_k \hat{a}^\dagger_{-{k}}.
$$

and \( \hat{P}_- = ( \hat{P}_+)^\dagger \).

<p>
This problem can be solved using what is called the quasi-spin formalism to obtain the 
exact results. Thereafter we will try again using the explicit Slater determinant formalism.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec74">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
One can show (and this is part of the project) that
$$
\left [ \hat{P}_+, \hat{P}_- \right ] = \sum_{k> 0} \left( \hat{a}^\dagger_k \hat{a}_k 
+ \hat{a}^\dagger_{-{k}} \hat{a}_{-{k}} - 1 \right) = \hat{N} - \Omega.
$$

Now define 
$$
\hat{P}_z = \frac{1}{2} ( \hat{N} -\Omega).
$$

Finally you can show
$$
\left [ \hat{P}_z , \hat{P}_\pm \right ] = \pm \hat{P}_\pm.
$$

This means the operators \( \hat{P}_\pm, \hat{P}_z \) form a so-called  \( SU(2) \) algebra, and we can 
use all our insights about angular momentum, even though there is no actual 
angular momentum involved.

<p>
So we rewrite the Hamiltonian to make this explicit:
$$
\hat{H} = -G \hat{P}_+ \hat{P}_- 
= -G \left( \hat{P}^2 - \hat{P}_z^2 + \hat{P}_z\right)
$$


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec75">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Because of the SU(2) algebra, we know that the eigenvalues of 
\( \hat{P}^2 \) must be of the form \( p(p+1) \), with \( p \) either integer or half-integer, and the eigenvalues of \( \hat{P}_z \) 
are \( m_p \) with \( p \geq | m_p| \), with \( m_p \) also integer or half-integer.

<p>
But because \( \hat{P}_z = (1/2)(\hat{N}-\Omega) \), we know that for \( N \) particles 
the value \( m_p = (N-\Omega)/2 \). Furthermore, the values of \( m_p \) range from 
\( -\Omega/2 \) (for \( N=0 \)) to \( +\Omega/2 \) (for \( N=2\Omega \), with all states filled).

<p>
We deduce the maximal \( p = \Omega/2 \) and for a given \( n \) the 
values range of \( p \) range from \( |N-\Omega|/2 \) to \( \Omega/2 \) in steps of 1 
(for an even number of particles)

<p>
Following Racah we introduce the notation
\( p = (\Omega - v)/2 \)
where \( v = 0, 2, 4,..., \Omega - |N-\Omega| \) 
With this it is easy to deduce that the eigenvalues of the pairing Hamiltonian are
$$
-G(N-v)(2\Omega +2-N-v)/4
$$

This also works for \( N \) odd, with \( v= 1,3,5, \dots \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec76">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Let's take a specific example: \( \Omega = 3 \) so there are 6 single-particle states, 
and \( N = 3 \), with \( v= 1,3 \). Therefore there are two distinct eigenvalues, 
$$
E = -2G, 0
$$

Now let's work this out explicitly. The single particle degrees of freedom are defined as

<p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <td align="center">\( k \)</td> <td align="center">\( m \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   1          </td> <td align="center">   -1/2       </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   -1         </td> <td align="center">   1/2        </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   2          </td> <td align="center">   -1/2       </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   -2         </td> <td align="center">   1/2        </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   3          </td> <td align="center">   -1/2       </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   -3         </td> <td align="center">   1/2        </td> </tr>
</tbody>
</table>
<p>
 There are  \( \left( \begin{array}{c}6 \\ 3 \end{array} \right) = 20 \) three-particle states, but there 
are 9 states with \( M = +1/2 \), namely
\( | 1,2,3 \rangle, |1,2,5\rangle, | 1,4,6 \rangle, | 2,3,4 \rangle, |2,3,6 \rangle, | 2,4,5 \rangle, | 2, 5, 6 \rangle, |3,4,6 \rangle, | 4,5,6 \rangle \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec77">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
In this basis, the operator 
$$
\hat{P}_+
= \hat{a}^\dagger_1 \hat{a}^\dagger_2 + \hat{a}^\dagger_3 \hat{a}^\dagger_4 +
\hat{a}^\dagger_5 \hat{a}^\dagger_6 
$$

From this we can determine that 
$$
\hat{P}_- | 1, 4, 6 \rangle = \hat{P}_- | 2, 3, 6 \rangle
= \hat{P}_- | 2, 4, 5 \rangle = 0
$$

so those states all have eigenvalue 0.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec78">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Now for further example, 
$$
\hat{P}_- | 1,2,3 \rangle = | 3 \rangle
$$

so
$$
\hat{P}_+ \hat{P}_- | 1,2,3\rangle = | 1,2,3\rangle+ | 3,4,3\rangle + | 5,6,3\rangle
$$

The second term vanishes because state 3 is occupied twice, and reordering the last 
term we
get
$$
\hat{P}_+ \hat{P}_- | 1,2,3\rangle = | 1,2,3\rangle+ |3, 5,6\rangle
$$

without picking up a phase.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec79">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Continuing in this fashion, with the previous ordering of the many-body states
(  \( | 1,2,3 \rangle, |1,2,5\rangle, | 1,4,6 \rangle, | 2,3,4 \rangle, |2,3,6 \rangle, | 2,4,5 \rangle, | 2, 5, 6 \rangle, |3,4,6 \rangle, | 4,5,6 \rangle \)) the 
Hamiltonian matrix of this system is 
$$
H = -G\left( 
\begin{array}{ccccccccc}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0  \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0  \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0  \\
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1  
\end{array} \right )
$$

This is useful for our project.  One can by hand confirm 
that there are 3 eigenvalues \( -2G \) and 6 with value zero.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec80">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Another example
Using the \( (1/2)^4 \) single-particle space, resulting in eight single-particle states

<p>
<table border="1">
<thead>
<tr><th align="center">Index</th> <td align="center">\( n \)</td> <td align="center">\( l \)</td> <td align="center">\( s \)</td> <td align="center">\( m_s \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1        </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   2        </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   3        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   4        </td> <td align="center">   1          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   5        </td> <td align="center">   2          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   6        </td> <td align="center">   2          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
<tr><td align="center">   7        </td> <td align="center">   3          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   -1/2         </td> </tr>
<tr><td align="center">   8        </td> <td align="center">   3          </td> <td align="center">   0          </td> <td align="center">   1/2        </td> <td align="center">   1/2          </td> </tr>
</tbody>
</table>
<p>
and then taking only 4-particle, \( M=0 \) states that have no `broken pairs', there are six basis Slater 
determinants:

<ul>
<li> \( |           1,           2 ,          3         ,       4  \rangle ,  \)</li>
<li> \( |            1      ,     2        ,        5         ,       6 \rangle ,  \)</li>
<li> \( |            1         ,       2     ,           7         ,       8  \rangle ,  \)</li>
<li> \( |            3        ,        4      ,          5          ,      6  \rangle ,  \)</li>
<li> \( |            3        ,        4      ,          7         ,       8  \rangle ,  \)</li>
<li> \( |            5        ,        6     ,           7     ,           8  \rangle  \)</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec81">Example case: pairing Hamiltonian </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Now we take the following Hamiltonian
$$
\hat{H} = \sum_n n \delta \hat{N}_n  - G \hat{P}^\dagger \hat{P}
$$

where 
$$
\hat{N}_n = \hat{a}^\dagger_{n, m=+1/2} \hat{a}_{n, m=+1/2} +
\hat{a}^\dagger_{n, m=-1/2} \hat{a}_{n, m=-1/2}
$$

and
$$
\hat{P}^\dagger = \sum_{n} \hat{a}^\dagger_{n, m=+1/2} \hat{a}^\dagger_{n, m=-1/2} 
$$

We can write down the $ 6 \times 6$  Hamiltonian in the basis from the prior slide:
$$
H = \left ( 
\begin{array}{cccccc}
2\delta -2G & -G & -G & -G & -G & 0 \\
 -G & 4\delta -2G & -G & -G & -0 & -G \\
-G & -G & 6\delta -2G & 0 & -G & -G \\
 -G & -G & 0 & 6\delta-2G & -G & -G \\
 -G & 0 & -G & -G & 8\delta-2G & -G \\
0 & -G & -G & -G & -G & 10\delta -2G 
\end{array} \right )
$$

(You should check by hand that this is correct.)

<p>
For \( \delta = 0 \) we have the closed form solution of  the g.s. energy given by \( -6G \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec82">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The goal is to compute the matrix elements of the Hamiltonian, specifically
matrix elements between many-body states (Slater determinants) of two-body
operators
$$
\sum_{p < q, r < s}V_{pqr} \hat{a}^\dagger_p \hat{a}^\dagger_q\hat{a}_s \hat{a}_r
$$

In particular we will need to compute
$$
\langle \beta | \hat{a}^\dagger_p \hat{a}^\dagger_q\hat{a}_s \hat{a}_r |\alpha \rangle
$$

where \( \alpha, \beta \) are indices labeling Slater determinants and \( p,q,r,s \) label
single-particle states.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec83">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Note: there are other, more efficient ways to do this than the method we describe, 
but you will
be able to produce a working code quickly.

<p>
As we coded in the first step,
a Slater determinant \( | \alpha \rangle \) with index \( \alpha \) is a
list of \( N \) occupied single-particle states \( i_1 < i_2 < i_3 \ldots i_N \).

<p>
Furthermore, for the two-body matrix elements \( V_{pqrs} \) we normally assume
\( p < q \) and \( r < s \). For our specific project, the interaction is much simpler and you can use this to simplify considerably the setup of a shell-model code for project 2.

<p>
What follows here is a more general, but still brute force, approach.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec84">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Write a function that:

<ol>
<li> Has as input the single-particle indices \( p,q,r,s \) for the two-body operator and the index \( \alpha \) for the ket Slater determinant;</li>
<li> Returns the index \( \beta \) of the unique (if any) Slater determinant such that</li>
</ol>

$$
| \beta \rangle = \pm \hat{a}^\dagger_p \hat{a}^\dagger_q\hat{a}_s \hat{a}_r |\alpha \rangle
$$

as well as the phase

<p>
This is equivalent to computing
$$
\langle \beta | \hat{a}^\dagger_p \hat{a}^\dagger_q\hat{a}_s \hat{a}_r |\alpha \rangle
$$


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec85">Building a Hamiltonian matrix, first step </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The first step can take as input an initial Slater determinant
(whose position in the list of basis Slater determinants is \( \alpha \)) written as an
ordered listed of occupied single-particle states, e.g. \( 1,2,5,8 \), and the
indices \( p,q,r,s \) from the two-body operator.

<p>
It will return another final Slater determinant if the single-particle states \( r \) and \( s \) are occupied, else it will return an 
empty Slater determinant
(all zeroes).

<p>
If \( r \) and \( s \) are in the list of occupied single particle states, then
replace the initial single-particle states \( ij \) as \( i \rightarrow r \) and \( j \rightarrow r \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec86">Building a Hamiltonian matrix, second step </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The second step will take the final Slater determinant 
from the first step (if not empty),
and then order by pairwise permutations (i.e., if the Slater determinant is
\( i_1, i_2, i_3, \ldots \), then if \( i_n > i_{n+1} \), interchange 
\( i_n \leftrightarrow i_{n+1} \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec87">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
It will also output a phase.  If any two single-particle occupancies are repeated, 
the phase is
0.  Otherwise it is +1 for an even permutation and -1 for an odd permutation to 
bring the final
Slater determinant into ascending order, \( j_1 < j_2 < j_3 \ldots \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec88">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<b>Example</b>: Suppose in the \( sd \) single-particle space that the initial 
Slater determinant
is \( 1,3,9,12 \). If \( p,q,r,s = 2,8,1,12 \), then after the first step the final Slater determinant
is \( 2,3,9,8 \).  The second step will return \( 2,3,8,9 \) and a phase of -1, 
because an odd number  of interchanges is required.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec89">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
<b>Example</b>: Suppose in the \( sd \) single-particle space that the initial 
Slater determinant
is \( 1,3,9,12 \). If \( p,q,r,s = 3,8,1,12 \), then after the first step the 
final  Slater determinant
is \( 3,3,9,8 \), but after the second step the phase is 0 
because the single-particle state 3 is
occupied twice.

<p>
Lastly, the final step  takes the ordered final Slater determinant and 
we search through the basis list to
determine its index in the many-body basis, that is, \( \beta \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec90">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
The Hamiltonian is then stored as an \( N_{SD} \times N_{SD} \) array of real numbers, which
can be allocated once you have created the many-body basis and know \( N_{SD} \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec91">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<ol>
<li> Initialize \( H(\alpha,\beta)=0.0 \)</li>
<li> Set up an outer loop over \( \beta \)</li>
<li> Loop over \( \alpha = 1, NSD \)</li>
<li> For each \( \alpha \), loop over \( a=1,ntbme \)  and fetch \( V(a) \) and the single-particle indices \( p,q,r,s \)</li> 
<li> If \( V(a) = 0 \) skip.  Otherwise, apply \( \hat{a}^\dagger_p\hat{a}^\dagger_q \hat{a}_s \hat{a}_r \) to the Slater determinant labeled by \( \alpha \).</li>
<li> Find, if any, the label \( \beta \) of the resulting Slater determinant and the phase (which is 0, +1, -1).</li>
<li> If phase \( \neq 0 \), then update \( H(\alpha,\beta) \)  as \( H(\alpha,\beta) + phase*V(a) \). The sum is important because multiple operators might contribute to the same matrix element.</li>
<li> Continue loop over \( a \)</li>
<li> Continue loop over \( \alpha \).</li>
<li> End the outer loop over \( \beta \).</li>
</ol>

You should force the resulting matrix \( H \) to be symmetric. To do this, when
updating \( H(\alpha,\beta) \), if \( \alpha \neq \beta \), also update \( H(\beta,\alpha) \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec92">Building a Hamiltonian matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
You will also need to include the single-particle energies. This is easy: they only
contribute to diagonal matrix elements, that is, \( H(\alpha,\alpha) \).  
Simply find the occupied single-particle states \( i \) and add the corresponding \( \epsilon(i) \).


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec93">Hamiltonian matrix without the bit representation </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
Consider the many-body state \( \Psi_{\lambda} \) expressed as linear combinations of
Slater determinants (\( SD \)) of orthonormal single-particle states \( \phi({\bf r}) \):
$$
\begin{equation}
\Psi_{\lambda} = \sum_i C_{\lambda i} SD_i
\label{_auto1}
\end{equation}
$$

Using the Slater-Condon rules the matrix elements of any one-body
(\( {\cal O}_1 \)) or two-body (\( {\cal O}_2 \)) operator expressed in the
determinant space have simple expressions involving one- and two-fermion
integrals in our given single-particle basis.
The diagonal elements are given by:
$$
\begin{eqnarray}
  \langle SD | {\cal O}_1 | SD \rangle & = & \sum_{i \in SD} \langle \phi_i | {\cal O}_1 | \phi_i \rangle \\
  \langle SD | {\cal O}_2 | SD \rangle & = & \frac{1}{2} \sum_{(i,j) \in SD}  
      \langle \phi_i \phi_j | {\cal O}_2 | \phi_i \phi_j \rangle - \nonumber \\
 & & 
      \langle \phi_i \phi_j | {\cal O}_2 | \phi_j \phi_i \rangle \nonumber 
\end{eqnarray}
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec94">Hamiltonian matrix without the bit representation, one and two-body operators </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
For two determinants which differ only by the substitution of single-particle states \( i \) with
a single-particle state \( j \):
$$
\begin{eqnarray}
  \langle SD | {\cal O}_1 | SD_i^j \rangle & = & \langle \phi_i | {\cal O}_1 | \phi_j \rangle \\
  \langle SD | {\cal O}_2 | SD_i^j \rangle & = & \sum_{k \in SD} 
      \langle \phi_i \phi_k | {\cal O}_2 | \phi_j \phi_k \rangle - 
      \langle \phi_i \phi_k | {\cal O}_2 | \phi_k \phi_j \rangle \nonumber
\end{eqnarray}
$$

For two determinants which differ by two single-particle states
$$
\begin{eqnarray}
  \langle SD | {\cal O}_1 | SD_{ik}^{jl} \rangle & = & 0 \\
  \langle SD | {\cal O}_2 | SD_{ik}^{jl} \rangle & = & 
      \langle \phi_i \phi_k | {\cal O}_2 | \phi_j \phi_l \rangle -
      \langle \phi_i \phi_k | {\cal O}_2 | \phi_l \phi_j \rangle \nonumber 
\end{eqnarray}
$$

All other matrix elements involving determinants with more than two
substitutions are zero.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec95">Strategies for setting up an algorithm </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
An efficient implementation of these rules requires

<ul>
<li> to find the number of single-particle state substitutions between two determinants</li>
<li> to find which single-particle states are involved in the substitution</li>
<li> to compute the phase factor if a reordering of the single-particle states has occured</li>
</ul>

We can solve this problem using our odometric approach or alternatively using a bit representation as discussed below and in more detail in 

<ul>
<li> <a href="https://github.com/scemama/slater_condon" target="_blank">Scemama and Gimer's article (Fortran codes)</a></li>
<li> <a href="https://arxiv.org/abs/0810.2644" target="_blank">Simen Kvaal's article on how to build an FCI code (C++ code)</a></li>
</ul>

We recommend in particular the article by Simen Kvaal. It contains nice general classes for creation and annihilation operators as well as the calculation of the phase (see below).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec96">Computing expectation values and transitions in the shell-model  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
When we diagonalize the Hamiltonian matrix, the eigenvectors are the coefficients \( C_{\lambda i} \) used 
to express the many-body state \( \Psi_{\lambda} \) in terms of  a linear combinations of
Slater determinants (\( SD \)) of orthonormal single-particle states \( \phi({\bf r}) \).

<p>
With these eigenvectors we can compute say the transition likelyhood of a one-body operator as
$$
\langle \Psi_{\lambda} \vert {\cal O}_1 \vert \Psi_{\sigma} \rangle  = 
\sum_{ij}C_{\lambda i}^*C_{\sigma j}  \langle SD_i | {\cal O}_1 | SD_j \rangle .
$$

Writing the one-body operator in second quantization as 
$$
{\cal O}_1  = \sum_{pq} \langle p \vert {\cal o}_1 \vert q\rangle a_p^{\dagger} a_q, 
$$

we have
$$
\langle \Psi_{\lambda} \vert {\cal O}_1 \vert \Psi_{\sigma} \rangle  = 
\sum_{pq}\langle p \vert {\cal o}_1 \vert q\rangle \sum_{ij}C_{\lambda i}^*C_{\sigma j}  \langle SD_i |a_p^{\dagger} a_q | SD_j \rangle .
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec97">Computing expectation values and transitions in the shell-model and spectroscopic factors  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The terms we need to evalute then are just the elements 
$$
\langle SD_i |a_p^{\dagger} a_q | SD_j \rangle, 
$$

which can be rewritten in terms of spectroscopic factors by inserting a complete set of Slater determinats as
$$
\langle SD_i |a_p^{\dagger} a_q | SD_j \rangle = \sum_{l}\langle SD_i \vert a_p^{\dagger}\vert SD_l\rangle \langle SD_l \vert  a_q \vert SD_j \rangle,
$$

where \( \langle SD_l\vert a_q(a_p^{\dagger})\vert SD_j\rangle \) are the spectroscopic factors. These can be easily evaluated in \( m \)-scheme. Using the Wigner-Eckart theorem we can transform these to a \( J \)-coupled scheme through so-called reduced matrix elements.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec98">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In the build-up of a shell-model or FCI code that is meant to tackle large dimensionalities
we need to deal with the action of the Hamiltonian \( \hat{H} \) on a
Slater determinant represented in second quantization as
$$
 |\alpha_1\dots \alpha_n\rangle = a_{\alpha_1}^{\dagger} a_{\alpha_2}^{\dagger} \dots a_{\alpha_n}^{\dagger} |0\rangle.
$$

The time consuming part stems from the action of the Hamiltonian
on the above determinant,
$$
\left(\sum_{\alpha\beta} \langle \alpha|t+u|\beta\rangle a_\alpha^{\dagger} a_\beta + \frac{1}{4} \sum_{\alpha\beta\gamma\delta}
                \langle \alpha \beta|\hat{v}|\gamma \delta\rangle a_\alpha^{\dagger} a_\beta^{\dagger} a_\delta a_\gamma\right)a_{\alpha_1}^{\dagger} a_{\alpha_2}^{\dagger} \dots a_{\alpha_n}^{\dagger} |0\rangle.
$$

A practically useful way to implement this action is to encode a Slater determinant as a bit pattern.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec99">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Assume that we have at our disposal \( n \) different single-particle states
\( \alpha_0,\alpha_2,\dots,\alpha_{n-1} \) and that we can distribute  among these states \( N\le n \) particles.

<p>
A Slater  determinant can then be coded as an integer of \( n \) bits. As an example, if we have \( n=16 \) single-particle states
\( \alpha_0,\alpha_1,\dots,\alpha_{15} \) and \( N=4 \) fermions occupying the states \( \alpha_3 \), \( \alpha_6 \), \( \alpha_{10} \) and \( \alpha_{13} \)
we could write this Slater determinant as  
$$
\Phi_{\Lambda} = a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle.
$$

The unoccupied single-particle states have bit value \( 0 \) while the occupied ones are represented by bit state \( 1 \). 
In the binary notation we would write this   16 bits long integer as
$$
\begin{array}{cccccccccccccccc}
{\alpha_0}&{\alpha_1}&{\alpha_2}&{\alpha_3}&{\alpha_4}&{\alpha_5}&{\alpha_6}&{\alpha_7} & {\alpha_8} &{\alpha_9} & {\alpha_{10}} &{\alpha_{11}} &{\alpha_{12}} &{\alpha_{13}} &{\alpha_{14}} & {\alpha_{15}} \\
{0} & {0} &{0} &{1} &{0} &{0} &{1} &{0} &{0} &{0} &{1} &{0} &{0} &{1} &{0} & {0} \\
\end{array}
$$

which translates into the decimal number
$$
2^3+2^6+2^{10}+2^{13}=9288.
$$

We can thus encode a Slater determinant as a bit pattern.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec100">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
With \( N \) particles that can be distributed over \( n \) single-particle states, the total number of Slater determinats (and defining thereby the dimensionality of the system) is
$$
\mathrm{dim}(\mathcal{H}) = \left(\begin{array}{c} n \\N\end{array}\right).
$$

The total number of bit patterns is \( 2^n \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec101">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We assume again that we have at our disposal \( n \) different single-particle orbits
\( \alpha_0,\alpha_2,\dots,\alpha_{n-1} \) and that we can distribute  among these orbits \( N\le n \) particles.
The ordering among these states is important as it defines the order of the creation operators.
We will write the determinant 
$$
\Phi_{\Lambda} = a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
$$

in a more compact way as 
$$
\Phi_{3,6,10,13} = |0001001000100100\rangle.
$$

The action of a creation operator is thus
$$
a^{\dagger}_{\alpha_4}\Phi_{3,6,10,13} = a^{\dagger}_{\alpha_4}|0001001000100100\rangle=a^{\dagger}_{\alpha_4}a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
$$

which becomes
$$
-a_{\alpha_3}^{\dagger} a^{\dagger}_{\alpha_4} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle=-|0001101000100100\rangle.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec102">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Similarly
$$
a^{\dagger}_{\alpha_6}\Phi_{3,6,10,13} = a^{\dagger}_{\alpha_6}|0001001000100100\rangle=a^{\dagger}_{\alpha_6}a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
$$

which becomes
$$
-a^{\dagger}_{\alpha_4} (a_{\alpha_6}^{\dagger})^ 2 a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle=0!
$$

This gives a simple recipe:  

<ul>
<li> If one of the bits \( b_j \) is \( 1 \) and we act with a creation operator on this bit, we return a null vector</li>
<li> If \( b_j=0 \), we set it to \( 1 \) and return a sign factor \( (-1)^l \), where \( l \) is the number of bits set before bit \( j \).</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec103">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Consider the action of \( a^{\dagger}_{\alpha_2} \) on various slater determinants:
$$
\begin{array}{ccc}
a^{\dagger}_{\alpha_2}\Phi_{00111}& = a^{\dagger}_{\alpha_2}|00111\rangle&=0\times |00111\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{01011}& = a^{\dagger}_{\alpha_2}|01011\rangle&=(-1)\times |01111\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{01101}& = a^{\dagger}_{\alpha_2}|01101\rangle&=0\times |01101\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{01110}& = a^{\dagger}_{\alpha_2}|01110\rangle&=0\times |01110\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{10011}& = a^{\dagger}_{\alpha_2}|10011\rangle&=(-1)\times |10111\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{10101}& = a^{\dagger}_{\alpha_2}|10101\rangle&=0\times |10101\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{10110}& = a^{\dagger}_{\alpha_2}|10110\rangle&=0\times |10110\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{11001}& = a^{\dagger}_{\alpha_2}|11001\rangle&=(+1)\times |11101\rangle\\
a^{\dagger}_{\alpha_2}\Phi_{11010}& = a^{\dagger}_{\alpha_2}|11010\rangle&=(+1)\times |11110\rangle\\
\end{array}
$$

What is the simplest way to obtain the phase when we act with one annihilation(creation) operator
on the given Slater determinant representation?
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec104">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We have an SD representation
$$
\Phi_{\Lambda} = a_{\alpha_0}^{\dagger} a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
$$

in a more compact way as
$$
\Phi_{0,3,6,10,13} = |1001001000100100\rangle.
$$

The action of
$$
a^{\dagger}_{\alpha_4}a_{\alpha_0}\Phi_{0,3,6,10,13} = a^{\dagger}_{\alpha_4}|0001001000100100\rangle=a^{\dagger}_{\alpha_4}a_{\alpha_3}^{\dagger} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle,
$$

which becomes
$$
-a_{\alpha_3}^{\dagger} a^{\dagger}_{\alpha_4} a_{\alpha_6}^{\dagger} a_{\alpha_{10}}^{\dagger} a_{\alpha_{13}}^{\dagger} |0\rangle=-|0001101000100100\rangle.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec105">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The action
$$
a_{\alpha_0}\Phi_{0,3,6,10,13} = |0001001000100100\rangle,
$$

can be obtained by subtracting the logical sum (AND operation) of \( \Phi_{0,3,6,10,13} \) and 
a word which represents only \( \alpha_0 \), that is
$$
|1000000000000000\rangle,
$$

from \( \Phi_{0,3,6,10,13}= |1001001000100100\rangle \).

<p>
This operation gives \( |0001001000100100\rangle \).

<p>
Similarly, we can form \( a^{\dagger}_{\alpha_4}a_{\alpha_0}\Phi_{0,3,6,10,13} \), say, by adding 
\( |0000100000000000\rangle \) to \( a_{\alpha_0}\Phi_{0,3,6,10,13} \), first checking that their logical sum
is zero in order to make sure that the state \( \alpha_4 \) is not already occupied.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec106">Operators in second quantization </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
It is trickier however to get the phase \( (-1)^l \). 
One possibility is as follows

<ul>
<li> Let \( S_1 \) be a word that represents the 1-bit to be removed and all others set to zero.</li>
</ul>

In the previous example \( S_1=|1000000000000000\rangle \)

<ul>
<li> Define \( S_2 \) as the similar word that represents the bit to be added, that is in our case</li>
</ul>

\( S_2=|0000100000000000\rangle \).

<ul>
<li> Compute then \( S=S_1-S_2 \), which here becomes</li>
</ul>

$$
S=|0111000000000000\rangle
$$


<ul>
<li> Perform then the logical AND operation of \( S \) with the word containing</li> 
</ul>

$$
\Phi_{0,3,6,10,13} = |1001001000100100\rangle,
$$

which results in \( |0001000000000000\rangle \). Counting the number of 1-bits gives the phase.  Here you need however an algorithm for bitcounting.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec107">Bit counting </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
We include here a python program which may aid in this direction. It uses bit manipulation functions from <a href="http://wiki.python.org/moin/BitManipulation" target="_blank"><tt>http://wiki.python.org/moin/BitManipulation</tt></a>.
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span></span><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">math</span>

<span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">A simple Python class for Slater determinant manipulation</span>
<span style="color: #CD5555">Bit-manipulation stolen from:</span>

<span style="color: #CD5555">http://wiki.python.org/moin/BitManipulation</span>
<span style="color: #CD5555">&quot;&quot;&quot;</span>

<span style="color: #228B22"># bitCount() counts the number of bits set (not an optimal function)</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">bitCount</span>(int_type):
    <span style="color: #CD5555">&quot;&quot;&quot; Count bits set in integer &quot;&quot;&quot;</span>
    count = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">while</span>(int_type):
        int_type &amp;= int_type - <span style="color: #B452CD">1</span>
        count += <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">return</span>(count)


<span style="color: #228B22"># testBit() returns a nonzero result, 2**offset, if the bit at &#39;offset&#39; is one.</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">testBit</span>(int_type, offset):
    mask = <span style="color: #B452CD">1</span> &lt;&lt; offset
    <span style="color: #8B008B; font-weight: bold">return</span>(int_type &amp; mask) &gt;&gt; offset

<span style="color: #228B22"># setBit() returns an integer with the bit at &#39;offset&#39; set to 1.</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">setBit</span>(int_type, offset):
    mask = <span style="color: #B452CD">1</span> &lt;&lt; offset
    <span style="color: #8B008B; font-weight: bold">return</span>(int_type | mask)

<span style="color: #228B22"># clearBit() returns an integer with the bit at &#39;offset&#39; cleared.</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">clearBit</span>(int_type, offset):
    mask = ~(<span style="color: #B452CD">1</span> &lt;&lt; offset)
    <span style="color: #8B008B; font-weight: bold">return</span>(int_type &amp; mask)

<span style="color: #228B22"># toggleBit() returns an integer with the bit at &#39;offset&#39; inverted, 0 -&gt; 1 and 1 -&gt; 0.</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">toggleBit</span>(int_type, offset):
    mask = <span style="color: #B452CD">1</span> &lt;&lt; offset
    <span style="color: #8B008B; font-weight: bold">return</span>(int_type ^ mask)

<span style="color: #228B22"># binary string made from number</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">bin0</span>(s):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">str</span>(s) <span style="color: #8B008B; font-weight: bold">if</span> s&lt;=<span style="color: #B452CD">1</span> <span style="color: #8B008B; font-weight: bold">else</span> bin0(s&gt;&gt;<span style="color: #B452CD">1</span>) + <span style="color: #658b00">str</span>(s&amp;<span style="color: #B452CD">1</span>)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">bin</span>(s, L = <span style="color: #B452CD">0</span>):
    ss = bin0(s)
    <span style="color: #8B008B; font-weight: bold">if</span> L &gt; <span style="color: #B452CD">0</span>:
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #CD5555">&#39;0&#39;</span>*(L-<span style="color: #658b00">len</span>(ss)) + ss
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #8B008B; font-weight: bold">return</span> ss
    
    

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">Slater</span>:
    <span style="color: #CD5555">&quot;&quot;&quot; Class for Slater determinants &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>):
        <span style="color: #658b00">self</span>.word = <span style="color: #658b00">int</span>(<span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">create</span>(<span style="color: #658b00">self</span>, j):
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&quot;c^+_&quot;</span> + <span style="color: #658b00">str</span>(j) + <span style="color: #CD5555">&quot; |&quot;</span> + <span style="color: #658b00">bin</span>(<span style="color: #658b00">self</span>.word) + <span style="color: #CD5555">&quot;&gt;  = &quot;</span>,
        <span style="color: #228B22"># Assume bit j is set, then we return zero.</span>
        s = <span style="color: #B452CD">0</span>
        <span style="color: #228B22"># Check if bit j is set.</span>
        isset = testBit(<span style="color: #658b00">self</span>.word, j)
        <span style="color: #8B008B; font-weight: bold">if</span> isset == <span style="color: #B452CD">0</span>:
            bits = bitCount(<span style="color: #658b00">self</span>.word &amp; ((<span style="color: #B452CD">1</span>&lt;&lt;j)-<span style="color: #B452CD">1</span>))
            s = <span style="color: #658b00">pow</span>(-<span style="color: #B452CD">1</span>, bits)
            <span style="color: #658b00">self</span>.word = setBit(<span style="color: #658b00">self</span>.word, j)

        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #658b00">str</span>(s) + <span style="color: #CD5555">&quot; x |&quot;</span> + <span style="color: #658b00">bin</span>(<span style="color: #658b00">self</span>.word) + <span style="color: #CD5555">&quot;&gt;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">return</span> s
        
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">annihilate</span>(<span style="color: #658b00">self</span>, j):
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&quot;c_&quot;</span> + <span style="color: #658b00">str</span>(j) + <span style="color: #CD5555">&quot; |&quot;</span> + <span style="color: #658b00">bin</span>(<span style="color: #658b00">self</span>.word) + <span style="color: #CD5555">&quot;&gt;  = &quot;</span>,
        <span style="color: #228B22"># Assume bit j is not set, then we return zero.</span>
        s = <span style="color: #B452CD">0</span>
        <span style="color: #228B22"># Check if bit j is set.</span>
        isset = testBit(<span style="color: #658b00">self</span>.word, j)
        <span style="color: #8B008B; font-weight: bold">if</span> isset == <span style="color: #B452CD">1</span>:
            bits = bitCount(<span style="color: #658b00">self</span>.word &amp; ((<span style="color: #B452CD">1</span>&lt;&lt;j)-<span style="color: #B452CD">1</span>))
            s = <span style="color: #658b00">pow</span>(-<span style="color: #B452CD">1</span>, bits)
            <span style="color: #658b00">self</span>.word = clearBit(<span style="color: #658b00">self</span>.word, j)

        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #658b00">str</span>(s) + <span style="color: #CD5555">&quot; x |&quot;</span> + <span style="color: #658b00">bin</span>(<span style="color: #658b00">self</span>.word) + <span style="color: #CD5555">&quot;&gt;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">return</span> s



<span style="color: #228B22"># Do some testing:</span>

phi = Slater()
phi.create(<span style="color: #B452CD">0</span>)
phi.create(<span style="color: #B452CD">1</span>)
phi.create(<span style="color: #B452CD">2</span>)
phi.create(<span style="color: #B452CD">3</span>)

<span style="color: #8B008B; font-weight: bold">print</span>


s = phi.annihilate(<span style="color: #B452CD">2</span>)
s = phi.create(<span style="color: #B452CD">7</span>)
s = phi.annihilate(<span style="color: #B452CD">0</span>)
s = phi.create(<span style="color: #B452CD">200</span>)
</pre></div>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec108">Eigenvalue problems, basic definitions </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Let us consider the matrix \( \mathbf{A} \) of dimension \( n \). The eigenvalues of
\( \mathbf{A} \) are defined through the matrix equation 
$$
   \mathbf{A}\mathbf{x}^{(\nu)} = \lambda^{(\nu)}\mathbf{x}^{(\nu)},
$$

where \( \lambda^{(\nu)} \) are the eigenvalues and \( \mathbf{x}^{(\nu)} \) the
corresponding eigenvectors.
Unless otherwise stated, when we use the wording eigenvector we mean the
right eigenvector. The left eigenvalue problem is defined as 
$$
\mathbf{x}^{(\nu)}_L\mathbf{A} = \lambda^{(\nu)}\mathbf{x}^{(\nu)}_L
$$

The above right eigenvector problem is equivalent to a set of \( n \) equations with \( n \) unknowns
\( x_i \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec109">Eigenvalue problems, basic definitions </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The eigenvalue problem can be rewritten as 
$$
   \left( \mathbf{A}-\lambda^{(\nu)} \mathbf{I} \right) \mathbf{x}^{(\nu)} = 0,
$$

with \( \mathbf{I} \) being the unity matrix. This equation provides
a solution to the problem if and only if the determinant
is zero, namely
$$
   \left| \mathbf{A}-\lambda^{(\nu)}\mathbf{I}\right| = 0,
$$

which in turn means that the determinant is a polynomial
of degree \( n \) in \( \lambda \) and in general we will have 
\( n \) distinct zeros.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec110">Eigenvalue problems, basic definitions </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The eigenvalues of a matrix 
\( \mathbf{A}\in {\mathbb{C}}^{n\times n} \)
are thus the \( n \) roots of its characteristic polynomial 
$$
P(\lambda) = det(\lambda\mathbf{I}-\mathbf{A}),
$$

or 
$$
  P(\lambda)= \prod_{i=1}^{n}\left(\lambda_i-\lambda\right).
$$

The set of these roots is called the spectrum and is denoted as
\( \lambda(\mathbf{A}) \).
If \( \lambda(\mathbf{A})=\left\{\lambda_1,\lambda_2,\dots ,\lambda_n\right\} \) then we have
$$
   det(\mathbf{A})= \lambda_1\lambda_2\dots\lambda_n, 
$$

and if we define the trace of \( \mathbf{A} \) as
$$
Tr(\mathbf{A})=\sum_{i=1}^n a_{ii}$$

then
$$
Tr(\mathbf{A})=\lambda_1+\lambda_2+\dots+\lambda_n.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec111">Abel-Ruffini Impossibility Theorem </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The <em>Abel-Ruffini</em> theorem (also known as Abel's impossibility theorem) 
states that there is no general solution in radicals to polynomial equations of degree five or higher.

<p>
The content of this theorem is frequently misunderstood. It does not assert that higher-degree polynomial equations are unsolvable. 
In fact, if the polynomial has real or complex coefficients, and we allow complex solutions, then every polynomial equation has solutions; this is the fundamental theorem of algebra. Although these solutions cannot always be computed exactly with radicals, they can be computed to any desired degree of accuracy using numerical methods such as the Newton-Raphson method or Laguerre method, and in this way they are no different from solutions to polynomial equations of the second, third, or fourth degrees.

<p>
The theorem only concerns the form that such a solution must take. The content of the theorem is 
that the solution of a higher-degree equation cannot in all cases be expressed in terms of the polynomial coefficients with a finite number of operations of addition, subtraction, multiplication, division and root extraction. Some polynomials of arbitrary degree, of which the simplest nontrivial example is the monomial equation \( ax^n = b \), are always solvable with a radical.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec112">Abel-Ruffini Impossibility Theorem </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>

<p>
The <em>Abel-Ruffini</em> theorem says that there are some fifth-degree equations whose solution cannot be so expressed. 
The equation \( x^5 - x + 1 = 0 \) is an example. Some other fifth degree equations can be solved by radicals, 
for example \( x^5 - x^4 - x + 1 = 0 \). The precise criterion that distinguishes between those equations that can be solved 
by radicals and those that cannot was given by Galois and is now part of Galois theory: 
a polynomial equation can be solved by radicals if and only if its Galois group is a solvable group.

<p>
Today, in the modern algebraic context, we say that second, third and fourth degree polynomial 
equations can always be solved by radicals because the symmetric groups \( S_2, S_3 \) and \( S_4 \) are solvable groups, 
whereas \( S_n \) is not solvable for \( n \ge 5 \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec113">Eigenvalue problems, basic definitions </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
In the present discussion we assume that our matrix is real and symmetric, that is 
\( \mathbf{A}\in {\mathbb{R}}^{n\times n} \).
The matrix \( \mathbf{A} \) has \( n \) eigenvalues
\( \lambda_1\dots \lambda_n \) (distinct or not). Let \( \mathbf{D} \) be the
diagonal matrix with the eigenvalues on the diagonal
$$
\mathbf{D}=    \left( \begin{array}{ccccccc} \lambda_1 & 0 & 0   & 0    & \dots  &0     & 0 \\
                                0 & \lambda_2 & 0 & 0    & \dots  &0     &0 \\
                                0   & 0 & \lambda_3 & 0  &0       &\dots & 0\\
                                \dots  & \dots & \dots & \dots  &\dots      &\dots & \dots\\
                                0   & \dots & \dots & \dots  &\dots       &\lambda_{n-1} & \\
                                0   & \dots & \dots & \dots  &\dots       &0 & \lambda_n
             \end{array} \right).
$$

If \( \mathbf{A} \) is real and symmetric then there exists a real orthogonal matrix \( \mathbf{S} \) such that
$$
     \mathbf{S}^T \mathbf{A}\mathbf{S}= \mathrm{diag}(\lambda_1,\lambda_2,\dots ,\lambda_n),
$$

and for \( j=1:n \) we have \( \mathbf{A}\mathbf{S}(:,j) = \lambda_j \mathbf{S}(:,j) \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec114">Eigenvalue problems, basic definitions </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
To obtain the eigenvalues of \( \mathbf{A}\in {\mathbb{R}}^{n\times n} \),
the strategy is to
perform a series of similarity transformations on the original
matrix \( \mathbf{A} \), in order to reduce it either into a  diagonal form as above
or into a  tridiagonal form.

<p>
We say that a matrix \( \mathbf{B} \) is a similarity
transform  of  \( \mathbf{A} \) if 
$$
     \mathbf{B}= \mathbf{S}^T \mathbf{A}\mathbf{S}, \hspace{1cm} \mathrm{where} \hspace{1cm}  \mathbf{S}^T\mathbf{S}=\mathbf{S}^{-1}\mathbf{S} =\mathbf{I}.
$$

The importance of a similarity transformation lies in the fact that
the resulting matrix has the same
eigenvalues, but the eigenvectors are in general different.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec115">Eigenvalue problems, basic definitions </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
To prove this we
start with  the eigenvalue problem and a similarity transformed matrix \( \mathbf{B} \).
$$
   \mathbf{A}\mathbf{x}=\lambda\mathbf{x} \hspace{1cm} \mathrm{and}\hspace{1cm} 
    \mathbf{B}= \mathbf{S}^T \mathbf{A}\mathbf{S}.
$$

We multiply the first equation on the left by \( \mathbf{S}^T \) and insert
\( \mathbf{S}^{T}\mathbf{S} = \mathbf{I} \) between \( \mathbf{A} \) and \( \mathbf{x} \). Then we get
$$
\begin{equation}
   (\mathbf{S}^T\mathbf{A}\mathbf{S})(\mathbf{S}^T\mathbf{x})=\lambda\mathbf{S}^T\mathbf{x} ,
\label{_auto2}
\end{equation}  
$$

which is the same as 
$$
   \mathbf{B} \left ( \mathbf{S}^T\mathbf{x} \right ) = \lambda \left (\mathbf{S}^T\mathbf{x}\right ).
$$

The variable  \( \lambda \) is an eigenvalue of \( \mathbf{B} \) as well, but with
eigenvector \( \mathbf{S}^T\mathbf{x} \).
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec116">Eigenvalue problems, basic definitions </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The basic philosophy is to

<ul>
 <li> Either apply subsequent similarity transformations (direct method) so that</li> 
</ul>

$$
\begin{equation}
   \mathbf{S}_N^T\dots \mathbf{S}_1^T\mathbf{A}\mathbf{S}_1\dots \mathbf{S}_N=\mathbf{D} ,
\label{_auto3}
\end{equation}
$$


<ul>
 <li> Or apply subsequent similarity transformations so that \( \mathbf{A} \) becomes tridiagonal (Householder) or upper/lower triangular (the <em>QR</em> method to be discussed later).</li> 
 <li> Thereafter, techniques for obtaining eigenvalues from tridiagonal matrices can be used.</li>
 <li> Or use so-called power methods</li>
 <li> Or use iterative methods (Krylov, Lanczos, Arnoldi). These methods are popular for huge matrix problems.</li>
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec117">Discussion of  methods for eigenvalues </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b>The general overview.</b>
<p>

<p>
One speaks normally of two main approaches to solving the eigenvalue problem.

<ul>
 <li> The first is the formal method, involving determinants and the  characteristic polynomial. This proves how many eigenvalues  there are, and is the way most of you learned about how to solve the eigenvalue problem, but for matrices of dimensions greater than 2 or 3, it is rather impractical.</li>
 <li> The other general approach is to use similarity or unitary tranformations  to reduce a matrix to diagonal form. This is normally done in two steps: first reduce to for example a <em>tridiagonal</em> form, and then to diagonal form. The main algorithms we will discuss in detail, Jacobi's and  Householder's  (so-called direct method) and Lanczos algorithms (an iterative method), follow this methodology.</li> 
</ul>
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec118">Eigenvalues methods </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Direct or non-iterative methods  require for matrices of dimensionality \( n\times n \) typically \( O(n^3) \) operations. These methods are normally called standard methods and are used for dimensionalities
\( n \sim 10^5 \) or smaller. A brief historical overview

<p>
<table border="1">
<thead>
<tr><th align="center">    Year   </th> <td align="center">    \( n \)     </td> <th align="center">                 </th> </tr>
</thead>
<tbody>
<tr><td align="center">   1950           </td> <td align="center">   \( n=20 \)          </td> <td align="center">   (Wilkinson)          </td> </tr>
<tr><td align="center">   1965           </td> <td align="center">   \( n=200 \)         </td> <td align="center">   (Forsythe et al.)    </td> </tr>
<tr><td align="center">   1980           </td> <td align="center">   \( n=2000 \)        </td> <td align="center">   Linpack              </td> </tr>
<tr><td align="center">   1995           </td> <td align="center">   \( n=20000 \)       </td> <td align="center">   Lapack               </td> </tr>
<tr><td align="center">   This decade    </td> <td align="center">   \( n\sim 10^5 \)    </td> <td align="center">   Lapack               </td> </tr>
</tbody>
</table>
<p>
shows that in the course of 60 years the dimension that  direct diagonalization methods can handle  has increased by almost a factor of
\( 10^4 \) (note this is for serial versions). However, it pales beside the progress achieved by computer hardware, from flops to petaflops, a factor of almost \( 10^{15} \). We see clearly played out in history the \( O(n^3) \) bottleneck  of direct matrix algorithms.

<p>
Sloppily speaking, when  \( n\sim 10^4 \) is cubed we have \( O(10^{12}) \) operations, which is smaller than the \( 10^{15} \) increase in flops.


</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec119">Discussion of methods for eigenvalues </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If the matrix to diagonalize is large and sparse, direct methods simply become impractical, 
also because
many of the direct methods tend to destroy sparsity. As a result large dense matrices may arise during the diagonalization procedure.  The idea behind iterative methods is to project the 
$n-$dimensional problem in smaller spaces, so-called Krylov subspaces. 
Given a matrix \( \mathbf{A} \) and a vector \( \mathbf{v} \), the associated Krylov sequences of vectors
(and thereby subspaces) 
\( \mathbf{v} \), \( \mathbf{A}\mathbf{v} \), \( \mathbf{A}^2\mathbf{v} \), \( \mathbf{A}^3\mathbf{v},\dots \), represent
successively larger Krylov subspaces.

<p>
<table border="1">
<thead>
<tr><th align="center">             Matrix             </th> <td align="center">\( \mathbf{A}\mathbf{x}=\mathbf{b} \)</td> <td align="center">\( \mathbf{A}\mathbf{x}=\lambda\mathbf{x} \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   \( \mathbf{A}=\mathbf{A}^* \)       </td> <td align="left">   Conjugate gradient                       </td> <td align="left">   Lanczos                                         </td> </tr>
<tr><td align="left">   \( \mathbf{A}\ne \mathbf{A}^* \)    </td> <td align="left">   GMRES etc                                </td> <td align="left">   Arnoldi                                         </td> </tr>
</tbody>
</table>

</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec120">Eigenvalues and Lanczos' method </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Basic features with a real symmetric matrix (and normally huge \( n> 10^6 \) and sparse) 
\( \hat{A} \) of dimension \( n\times n \):

<ul>
<li> Lanczos' algorithm generates a sequence of real tridiagonal matrices \( T_k \) of dimension \( k\times k \) with \( k\le n \), with the property that the extremal eigenvalues of \( T_k \) are progressively better estimates of \( \hat{A} \)' extremal eigenvalues.* The method converges to the extremal eigenvalues.</li>
<li> The similarity transformation is</li> 
</ul>

$$
\hat{T}= \hat{Q}^{T}\hat{A}\hat{Q},
$$

with the first vector \( \hat{Q}\hat{e}_1=\hat{q}_1 \).

<p>
We are going to solve iteratively
$$
\hat{T}= \hat{Q}^{T}\hat{A}\hat{Q},
$$

with the first vector \( \hat{Q}\hat{e}_1=\hat{q}_1 \).
We can write out the matrix \( \hat{Q} \) in terms of its column vectors 
$$
\hat{Q}=\left[\hat{q}_1\hat{q}_2\dots\hat{q}_n\right].
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec121">Eigenvalues and Lanczos' method, tridiagonal matrix </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
The matrix
$$
\hat{T}= \hat{Q}^{T}\hat{A}\hat{Q},
$$

can be written as 
$$
    \hat{T} = \left(\begin{array}{cccccc}
                           \alpha_1& \beta_1 & 0 &\dots   & \dots &0 \\
                           \beta_1 & \alpha_2 & \beta_2 &0 &\dots &0 \\
                           0& \beta_2 & \alpha_3 & \beta_3 & \dots &0 \\
                           \dots& \dots   & \dots &\dots   &\dots & 0 \\
                           \dots&   &  &\beta_{n-2}  &\alpha_{n-1}& \beta_{n-1} \\
                           0&  \dots  &\dots  &0   &\beta_{n-1} & \alpha_{n} \\
                      \end{array} \right)
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec122">Eigenvalues and Lanczos' method, tridiagonal and orthogonal matrices </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
Using the fact that 
$$
\hat{Q}\hat{Q}^T=\hat{I}, 
$$

we can rewrite 
$$
\hat{T}= \hat{Q}^{T}\hat{A}\hat{Q},
$$

as 
$$
\hat{Q}\hat{T}= \hat{A}\hat{Q}.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec123">Eigenvalues and Lanczos' method </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
If we equate columns 
$$
\hat{T} = \left(\begin{array}{cccccc}
        \alpha_1& \beta_1 & 0 &\dots   & \dots &0 \\
        \beta_1 & \alpha_2 & \beta_2 &0 &\dots &0 \\
        0& \beta_2 & \alpha_3 & \beta_3 & \dots &0 \\
        \dots& \dots   & \dots &\dots   &\dots & 0 \\
        \dots&   &  &\beta_{n-2}  &\alpha_{n-1}& \beta_{n-1} \\
        0&  \dots  &\dots  &0   &\beta_{n-1} & \alpha_{n} \\
        \end{array} \right)
$$

we obtain
$$
\hat{A}\hat{q}_k=\beta_{k-1}\hat{q}_{k-1}+\alpha_k\hat{q}_k+\beta_k\hat{q}_{k+1}.
$$
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec124">Eigenvalues and Lanczos' method, defining the Lanczos' vectors  </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We have thus
$$
\hat{A}\hat{q}_k=\beta_{k-1}\hat{q}_{k-1}+\alpha_k\hat{q}_k+\beta_k\hat{q}_{k+1},
$$

with \( \beta_0\hat{q}_0=0 \) for \( k=1:n-1 \). Remember that the vectors \( \hat{q}_k \)  are orthornormal and this implies
$$
\alpha_k=\hat{q}_k^T\hat{A}\hat{q}_k,
$$

and these vectors are called Lanczos vectors.
</div>


<p>
<!-- !split --><br><br><br><br><br><br><br><br><br><br>

<h2 id="___sec125">Eigenvalues and Lanczos' method, basic steps </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
We have thus
$$
\hat{A}\hat{q}_k=\beta_{k-1}\hat{q}_{k-1}+\alpha_k\hat{q}_k+\beta_k\hat{q}_{k+1},
$$

with \( \beta_0\hat{q}_0=0 \) for \( k=1:n-1 \) and 
$$
\alpha_k=\hat{q}_k^T\hat{A}\hat{q}_k.
$$

If 
$$
\hat{r}_k=(\hat{A}-\alpha_k\hat{I})\hat{q}_k-\beta_{k-1}\hat{q}_{k-1},
$$

is non-zero, then 
$$
\hat{q}_{k+1}=\hat{r}_{k}/\beta_k,
$$

with \( \beta_k=\pm ||\hat{r}_{k}||_2 \).
</div>


<p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright --> &copy; 2013-2018, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>


</body>
</html>
    

